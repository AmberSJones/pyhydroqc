
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.0.0">
    
    
      
        <title>pyhydroqc Documentation</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.a3f8f96a.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.7fa14f5b.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="css/ansi-colours.css">
    
      <link rel="stylesheet" href="css/jupyter-cells.css">
    
      <link rel="stylesheet" href="css/pandas-dataframe.css">
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#pyhydroqc-functions" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="." title="pyhydroqc Documentation" class="md-header__button md-logo" aria-label="pyhydroqc Documentation">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            pyhydroqc Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Home
            
          </span>
        </div>
      </div>
    </div>
    <div class="md-header__options">
      
    </div>
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/AmberSJones/PyHydroQC/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="pyhydroqc Documentation" class="md-nav__button md-logo" aria-label="pyhydroqc Documentation">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    pyhydroqc Documentation
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/AmberSJones/PyHydroQC/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Home
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="." class="md-nav__link md-nav__link--active">
        Home
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#rules-based-detection-and-correction-functions-module-rules_detect" class="md-nav__link">
    Rules Based Detection and Correction Functions (module: rules_detect)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect" class="md-nav__link">
    PyHydroQC.rules_detect
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect.add_labels" class="md-nav__link">
    add_labels()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect.group_size" class="md-nav__link">
    group_size()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect.interpolate" class="md-nav__link">
    interpolate()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect.persistence" class="md-nav__link">
    persistence()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect.range_check" class="md-nav__link">
    range_check()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#calibration-detection-and-correction-functions-module-calibration" class="md-nav__link">
    Calibration Detection and Correction Functions (module: calibration)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration" class="md-nav__link">
    PyHydroQC.calibration
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration.calib_edge_detect" class="md-nav__link">
    calib_edge_detect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration.calib_overlap" class="md-nav__link">
    calib_overlap()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration.calib_persist_detect" class="md-nav__link">
    calib_persist_detect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration.find_gap" class="md-nav__link">
    find_gap()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration.lin_drift_cor" class="md-nav__link">
    lin_drift_cor()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#utilities-functions-module-anomaly_utilities" class="md-nav__link">
    Utilities Functions (module: anomaly_utilities)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities" class="md-nav__link">
    PyHydroQC.anomaly_utilities
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.aggregate_results" class="md-nav__link">
    aggregate_results()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.anomaly_events" class="md-nav__link">
    anomaly_events()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.assign_cm" class="md-nav__link">
    assign_cm()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.compare_events" class="md-nav__link">
    compare_events()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.detect_anomalies" class="md-nav__link">
    detect_anomalies()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.detect_anomalies_cons" class="md-nav__link">
    detect_anomalies_cons()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.event_metrics" class="md-nav__link">
    event_metrics()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.get_data" class="md-nav__link">
    get_data()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.group_bools" class="md-nav__link">
    group_bools()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.metrics" class="md-nav__link">
    metrics()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.set_cons_threshold" class="md-nav__link">
    set_cons_threshold()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.set_dynamic_threshold" class="md-nav__link">
    set_dynamic_threshold()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.xfade" class="md-nav__link">
    xfade()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#model-development-and-training-functions-module-modeling_utilities" class="md-nav__link">
    Model Development and Training Functions (module: modeling_utilities)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities" class="md-nav__link">
    PyHydroQC.modeling_utilities
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.build_arima_model" class="md-nav__link">
    build_arima_model()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_bidir_model" class="md-nav__link">
    create_bidir_model()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_bidir_sequenced_dataset" class="md-nav__link">
    create_bidir_sequenced_dataset()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_bidir_training_dataset" class="md-nav__link">
    create_bidir_training_dataset()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_scaler" class="md-nav__link">
    create_scaler()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_sequenced_dataset" class="md-nav__link">
    create_sequenced_dataset()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_training_dataset" class="md-nav__link">
    create_training_dataset()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_vanilla_model" class="md-nav__link">
    create_vanilla_model()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.LSTM_multivar" class="md-nav__link">
    LSTM_multivar()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.LSTM_multivar_bidir" class="md-nav__link">
    LSTM_multivar_bidir()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.LSTM_univar" class="md-nav__link">
    LSTM_univar()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.LSTM_univar_bidir" class="md-nav__link">
    LSTM_univar_bidir()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.pdq" class="md-nav__link">
    pdq()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.train_model" class="md-nav__link">
    train_model()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#workflow-functions-for-model-based-anomaly-detection-model_workflow" class="md-nav__link">
    Workflow Functions for Model Based Anomaly Detection (model_workflow)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.model_workflow" class="md-nav__link">
    PyHydroQC.model_workflow
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.model_workflow.ModelType" class="md-nav__link">
    ModelType
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.model_workflow.ARIMA_detect" class="md-nav__link">
    ARIMA_detect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.model_workflow.LSTM_detect_multivar" class="md-nav__link">
    LSTM_detect_multivar()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.model_workflow.LSTM_detect_univar" class="md-nav__link">
    LSTM_detect_univar()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#model-based-correction-functions-arima_correct" class="md-nav__link">
    Model Based Correction Functions (ARIMA_correct)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.ARIMA_correct" class="md-nav__link">
    PyHydroQC.ARIMA_correct
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.ARIMA_correct.ARIMA_forecast" class="md-nav__link">
    ARIMA_forecast()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.ARIMA_correct.ARIMA_group" class="md-nav__link">
    ARIMA_group()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.ARIMA_correct.generate_corrections" class="md-nav__link">
    generate_corrections()
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="about/" class="md-nav__link">
        About
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="Examples/SingleSiteExample.ipynb" class="md-nav__link">
        Example
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#rules-based-detection-and-correction-functions-module-rules_detect" class="md-nav__link">
    Rules Based Detection and Correction Functions (module: rules_detect)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect" class="md-nav__link">
    PyHydroQC.rules_detect
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect.add_labels" class="md-nav__link">
    add_labels()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect.group_size" class="md-nav__link">
    group_size()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect.interpolate" class="md-nav__link">
    interpolate()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect.persistence" class="md-nav__link">
    persistence()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.rules_detect.range_check" class="md-nav__link">
    range_check()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#calibration-detection-and-correction-functions-module-calibration" class="md-nav__link">
    Calibration Detection and Correction Functions (module: calibration)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration" class="md-nav__link">
    PyHydroQC.calibration
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration.calib_edge_detect" class="md-nav__link">
    calib_edge_detect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration.calib_overlap" class="md-nav__link">
    calib_overlap()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration.calib_persist_detect" class="md-nav__link">
    calib_persist_detect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration.find_gap" class="md-nav__link">
    find_gap()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.calibration.lin_drift_cor" class="md-nav__link">
    lin_drift_cor()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#utilities-functions-module-anomaly_utilities" class="md-nav__link">
    Utilities Functions (module: anomaly_utilities)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities" class="md-nav__link">
    PyHydroQC.anomaly_utilities
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.aggregate_results" class="md-nav__link">
    aggregate_results()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.anomaly_events" class="md-nav__link">
    anomaly_events()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.assign_cm" class="md-nav__link">
    assign_cm()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.compare_events" class="md-nav__link">
    compare_events()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.detect_anomalies" class="md-nav__link">
    detect_anomalies()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.detect_anomalies_cons" class="md-nav__link">
    detect_anomalies_cons()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.event_metrics" class="md-nav__link">
    event_metrics()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.get_data" class="md-nav__link">
    get_data()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.group_bools" class="md-nav__link">
    group_bools()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.metrics" class="md-nav__link">
    metrics()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.set_cons_threshold" class="md-nav__link">
    set_cons_threshold()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.set_dynamic_threshold" class="md-nav__link">
    set_dynamic_threshold()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.anomaly_utilities.xfade" class="md-nav__link">
    xfade()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#model-development-and-training-functions-module-modeling_utilities" class="md-nav__link">
    Model Development and Training Functions (module: modeling_utilities)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities" class="md-nav__link">
    PyHydroQC.modeling_utilities
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.build_arima_model" class="md-nav__link">
    build_arima_model()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_bidir_model" class="md-nav__link">
    create_bidir_model()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_bidir_sequenced_dataset" class="md-nav__link">
    create_bidir_sequenced_dataset()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_bidir_training_dataset" class="md-nav__link">
    create_bidir_training_dataset()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_scaler" class="md-nav__link">
    create_scaler()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_sequenced_dataset" class="md-nav__link">
    create_sequenced_dataset()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_training_dataset" class="md-nav__link">
    create_training_dataset()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.create_vanilla_model" class="md-nav__link">
    create_vanilla_model()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.LSTM_multivar" class="md-nav__link">
    LSTM_multivar()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.LSTM_multivar_bidir" class="md-nav__link">
    LSTM_multivar_bidir()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.LSTM_univar" class="md-nav__link">
    LSTM_univar()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.LSTM_univar_bidir" class="md-nav__link">
    LSTM_univar_bidir()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.pdq" class="md-nav__link">
    pdq()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.modeling_utilities.train_model" class="md-nav__link">
    train_model()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#workflow-functions-for-model-based-anomaly-detection-model_workflow" class="md-nav__link">
    Workflow Functions for Model Based Anomaly Detection (model_workflow)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.model_workflow" class="md-nav__link">
    PyHydroQC.model_workflow
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.model_workflow.ModelType" class="md-nav__link">
    ModelType
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.model_workflow.ARIMA_detect" class="md-nav__link">
    ARIMA_detect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.model_workflow.LSTM_detect_multivar" class="md-nav__link">
    LSTM_detect_multivar()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.model_workflow.LSTM_detect_univar" class="md-nav__link">
    LSTM_detect_univar()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#model-based-correction-functions-arima_correct" class="md-nav__link">
    Model Based Correction Functions (ARIMA_correct)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.ARIMA_correct" class="md-nav__link">
    PyHydroQC.ARIMA_correct
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.ARIMA_correct.ARIMA_forecast" class="md-nav__link">
    ARIMA_forecast()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.ARIMA_correct.ARIMA_group" class="md-nav__link">
    ARIMA_group()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyHydroQC.ARIMA_correct.generate_corrections" class="md-nav__link">
    generate_corrections()
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/AmberSJones/PyHydroQC/edit/master/docs/index.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="pyhydroqc-functions">PyHydroQC Functions</h1>
<p>The PyHydroQC Python package contains functions for anomaly detection and correction of aquatic sensor data.</p>
<p>The package may be installed from the <a href="https://test.pypi.org/project/pyhydroqc-AmberSJones/">Test Python Package Index</a>.</p>
<p>Also see the <a href="https://github.com/AmberSJones/PyHydroQC">GitHub repository</a>.</p>
<p>All functions available in the PyHydroQC package are documented here. See the example notebooks and scripts for implementation of the steps and workflow for anomaly detection and correction.</p>
<h2 id="rules-based-detection-and-correction-functions-module-rules_detect">Rules Based Detection and Correction Functions (module: rules_detect)</h2>
<div class="doc doc-object doc-module">
<h2 class="hidden-toc" id="PyHydroQC.rules_detect" style="visibility: hidden; position: absolute;">
        </h2>
<div class="doc doc-contents first">
<div class="doc doc-children">
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.rules_detect.add_labels">

<code class="highlight language-python"><span class="n">add_labels</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">value</span><span class="o">=-</span><span class="mi">9999</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>add_labels adds an indicator that there is an anomalous value that should have been labeled by the expert but was not. Considers a specified 'no data value' (default is -9999) as well as null values. Only relevant if comparing to technician/expert labeled data.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with columns:
'raw' of raw data
'cor' of corrected data
'labeled_anomaly' booleans where True=1 corresponds to anomalies</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>value</code></td>
<td><code></code></td>
<td>
<p>the 'no data value' in the data for which the function checks.</p>
</td>
<td><code>-9999</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td>
<p>data frame with column 'labeled_anomaly' modified.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/rules_detect.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">add_labels</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">value</span><span class="o">=-</span><span class="mi">9999</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    add_labels adds an indicator that there is an anomalous value that should have been labeled by the expert but was not. Considers a specified 'no data value' (default is -9999) as well as null values. Only relevant if comparing to technician/expert labeled data.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with columns:</span>
<span class="sd">            'raw' of raw data</span>
<span class="sd">            'cor' of corrected data</span>
<span class="sd">            'labeled_anomaly' booleans where True=1 corresponds to anomalies</span>
<span class="sd">        value: the 'no data value' in the data for which the function checks.</span>
<span class="sd">    Returns:</span>
<span class="sd">        df: data frame with column 'labeled_anomaly' modified.</span>
<span class="sd">    """</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'labeled_anomaly'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">df</span><span class="p">[</span><span class="s1">'raw'</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'cor'</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'cor'</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()),</span> <span class="kc">True</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">'labeled_anomaly'</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">df</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.rules_detect.group_size">

<code class="highlight language-python"><span class="n">group_size</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>group_size determines the size of the largest consecutive group of anomalous points.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with column 'anomaly'.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size</code></td>
<td>
<p>length of the largest consecutive group of anomalous points.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/rules_detect.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">group_size</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    group_size determines the size of the largest consecutive group of anomalous points.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with column 'anomaly'.</span>
<span class="sd">    Returns:</span>
<span class="sd">        size: length of the largest consecutive group of anomalous points.</span>
<span class="sd">    """</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">'anomaly'</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">temp</span><span class="p">[</span><span class="s1">'value_grp'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">anomaly_events</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'value_grp'</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'value_grp'</span><span class="p">][</span><span class="n">temp</span><span class="p">[</span><span class="s1">'value_grp'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'value_grp'</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'value_grp'</span><span class="p">][</span><span class="n">temp</span><span class="p">[</span><span class="s1">'value_grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">):</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'value_grp'</span><span class="p">][</span><span class="n">temp</span><span class="p">[</span><span class="s1">'value_grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">size</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.rules_detect.interpolate">

<code class="highlight language-python"><span class="n">interpolate</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>interpolate performs linear interpolation on points identified as anomalous (typically by rules based approaches).</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with a column 'raw' of raw data and a boolean column 'anomaly'.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>limit</code></td>
<td><code></code></td>
<td>
<p>maximum length/number of points of acceptable interpolation. If an event is exceeds this length, it will not be interpolated.</p>
</td>
<td><code>10000</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td>
<p>data frame with added column 'observed' for interpolated data.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/rules_detect.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    interpolate performs linear interpolation on points identified as anomalous (typically by rules based approaches).</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with a column 'raw' of raw data and a boolean column 'anomaly'.</span>
<span class="sd">        limit: maximum length/number of points of acceptable interpolation. If an event is exceeds this length, it will not be interpolated.</span>
<span class="sd">    Returns:</span>
<span class="sd">        df: data frame with added column 'observed' for interpolated data.</span>
<span class="sd">    """</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'observed'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">'raw'</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'observed'</span><span class="p">]</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">'linear'</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">limit_direction</span><span class="o">=</span><span class="s1">'both'</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.rules_detect.persistence">

<code class="highlight language-python"><span class="n">persistence</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">output_grp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>persistence adds an anomalous label in the data frame if data repeat for specified length.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with a column 'raw' of raw data and a boolean column 'anomaly' (typically output of range_check)</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>length</code></td>
<td><code></code></td>
<td>
<p>duration of persistent/repeated values to be flagged</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>output_grp</code></td>
<td><code></code></td>
<td>
<p>boolean to indicate whether the length of persistence should be output as a column in the original dataframe.</p>
</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td>
<p>dataframe with column 'anomaly' modified and added column 'persist_grp' that indexes points as part of persistent groups
persist_count: total number of persistent points in the data frame</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/rules_detect.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">persistence</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">output_grp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    persistence adds an anomalous label in the data frame if data repeat for specified length.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with a column 'raw' of raw data and a boolean column 'anomaly' (typically output of range_check)</span>
<span class="sd">        length: duration of persistent/repeated values to be flagged</span>
<span class="sd">        output_grp: boolean to indicate whether the length of persistence should be output as a column in the original dataframe.</span>
<span class="sd">    Returns:</span>
<span class="sd">        df: dataframe with column 'anomaly' modified and added column 'persist_grp' that indexes points as part of persistent groups</span>
<span class="sd">        persist_count: total number of persistent points in the data frame</span>
<span class="sd">    """</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">'raw'</span><span class="p">,</span> <span class="s1">'anomaly'</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">anomaly_events</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">][</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">):</span>
            <span class="n">temp</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">][</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">persist_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">output_grp</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">persist_count</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.rules_detect.range_check">

<code class="highlight language-python"><span class="n">range_check</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">minimum</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>range_check adds a column to data frame with label if data are out of range.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with a column 'raw' of raw data.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>maximum</code></td>
<td><code></code></td>
<td>
<p>maximum acceptable value - above this value, data are anomalous</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>minimum</code></td>
<td><code></code></td>
<td>
<p>minimum acceptable value - below this value, data are anomalous</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td>
<p>data frame with an added column 'anomaly' with boolean where 1 = True for anomalous
range_count: total number of anomalies from this check</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/rules_detect.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">range_check</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">minimum</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    range_check adds a column to data frame with label if data are out of range.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with a column 'raw' of raw data.</span>
<span class="sd">        maximum: maximum acceptable value - above this value, data are anomalous</span>
<span class="sd">        minimum: minimum acceptable value - below this value, data are anomalous</span>
<span class="sd">    Returns:</span>
<span class="sd">        df: data frame with an added column 'anomaly' with boolean where 1 = True for anomalous</span>
<span class="sd">        range_count: total number of anomalies from this check</span>
<span class="sd">    """</span>
    <span class="c1"># could do some sort of look up table with the values for each sensor</span>
    <span class="c1"># could also add seasonal checks</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s1">'anomaly = raw &gt; @maximum or raw &lt; @minimum'</span><span class="p">)</span>
    <span class="n">range_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">range_count</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<h2 id="calibration-detection-and-correction-functions-module-calibration">Calibration Detection and Correction Functions (module: calibration)</h2>
<div class="doc doc-object doc-module">
<h2 class="hidden-toc" id="PyHydroQC.calibration" style="visibility: hidden; position: absolute;">
        </h2>
<div class="doc doc-contents first">
<div class="doc doc-children">
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.calibration.calib_edge_detect">

<code class="highlight language-python"><span class="n">calib_edge_detect</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">calib_params</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">nan</span><span class="p">,</span> <span class="n">num_events</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">nan</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>calib_edge_detect seeks to find likely calibration event candidates by using edge filtering</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>observed</code></td>
<td><code></code></td>
<td>
<p>time series of observations</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>width</code></td>
<td><code></code></td>
<td>
<p>the width of the edge detection filter</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>calib_params</code></td>
<td><code></code></td>
<td>
<p>parameters defined in the parameters file
 hour_low: earliest hour for calibrations to have occurred
 hour_high: latest hour for calibrations to have occurred</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>threshold</code></td>
<td><code></code></td>
<td>
<p>used for determining candidates from edge filter results</p>
</td>
<td><code>nan</code></td>
</tr>
<tr>
<td><code>num_events</code></td>
<td><code></code></td>
<td>
<p>the number of calibration event candidates to return</p>
</td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>alpha</code></td>
<td><code></code></td>
<td>
<p>used for determining a threshold from the data</p>
</td>
<td><code>nan</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>candidates</code></td>
<td>
<p>datetimes of the most likely calibration event candidates
edge_diff: differences indicating degree of edges</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/calibration.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">calib_edge_detect</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">calib_params</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">"nan"</span><span class="p">),</span> <span class="n">num_events</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">"nan"</span><span class="p">)):</span>
    <span class="sd">"""</span>
<span class="sd">   calib_edge_detect seeks to find likely calibration event candidates by using edge filtering</span>
<span class="sd">   Arguments:</span>
<span class="sd">       observed: time series of observations</span>
<span class="sd">       width: the width of the edge detection filter</span>
<span class="sd">       calib_params: parameters defined in the parameters file</span>
<span class="sd">            hour_low: earliest hour for calibrations to have occurred</span>
<span class="sd">            hour_high: latest hour for calibrations to have occurred</span>
<span class="sd">       threshold: used for determining candidates from edge filter results</span>
<span class="sd">       num_events: the number of calibration event candidates to return</span>
<span class="sd">       alpha: used for determining a threshold from the data</span>
<span class="sd">   Returns:</span>
<span class="sd">       candidates: datetimes of the most likely calibration event candidates</span>
<span class="sd">       edge_diff: differences indicating degree of edges</span>
<span class="sd">    """</span>
    <span class="c1"># TODO: add functionality for num_events and alpha</span>

    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edge_diff</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">observed</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>  <span class="c1"># diff['val'] is the filter output</span>
    <span class="n">edge_diff</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span> <span class="o">-</span> <span class="n">width</span><span class="p">):</span>  <span class="c1"># loop over every possible difference calculation</span>
        <span class="c1"># implement the edge detection filter - difference of the sums of before and after data</span>
        <span class="n">edge_diff</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">observed</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">width</span><span class="p">:</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">observed</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">width</span><span class="p">]))</span> <span class="o">/</span> <span class="n">width</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>  <span class="c1"># if the function is being called with a threshold</span>

        <span class="c1"># iterate over each day, this assumes that a sensor will not be calibrated twice in one day</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">day</span> <span class="ow">in</span> <span class="n">edge_diff</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">edge_diff</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">day</span><span class="p">[</span><span class="s1">'val'</span><span class="p">])))</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>  <span class="c1"># if any value is above the threshold in that day</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">day</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()[</span><span class="s1">'val'</span><span class="p">]))</span>  <span class="c1"># add it to the list of calibration candidates</span>

    <span class="c1"># specify that calibrations would only occur on work days and between specified hours of the day</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[(</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span><span class="o">.</span><span class="n">dayofweek</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span>
                            <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span><span class="o">.</span><span class="n">hour</span> <span class="o">&gt;=</span> <span class="n">calib_params</span><span class="p">[</span><span class="s1">'hour_low'</span><span class="p">])</span> <span class="o">&amp;</span>
                            <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span><span class="o">.</span><span class="n">hour</span> <span class="o">&lt;=</span> <span class="n">calib_params</span><span class="p">[</span><span class="s1">'hour_high'</span><span class="p">])]</span>

    <span class="k">return</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">edge_diff</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.calibration.calib_overlap">

<code class="highlight language-python"><span class="n">calib_overlap</span><span class="p">(</span><span class="n">sensor_names</span><span class="p">,</span> <span class="n">input_array</span><span class="p">,</span> <span class="n">calib_params</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>calib_overlap seeks to identify calibration events by identifying where overlaps occur between multiple sensors.
Calls the calib_detect function to identify events with a defined persistence length during certain days of the
week (M-F) and hours of the day.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sensor_names</code></td>
<td><code></code></td>
<td>
<p>list of sensors to be considered for overlap.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>input_array</code></td>
<td><code></code></td>
<td>
<p>array of data frames each with columns:
'observed' of observed data
'anomaly' booleans where True=1 corresponds to anomalies
'persist_grp' with indices of persistent groups (output of the persist function)</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>calib_params</code></td>
<td><code></code></td>
<td>
<p>parameters defined in the parameters file
persist_high: longest length of the persistent group
perist_low: shortest length of the persistent group
hour_low: earliest hour for calibrations to have occurred
hour_high: latest hour for calibrations to have occurred</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>all_calib</code></td>
<td>
<p>array of data frames (one for each sensor) of booleans indicating whether the conditions were met
for a possible calibration event.
all_calib_dates: array of datetimes (one for each sensor) for which the conditions were met for a possible
calibration event.
df_all_calib: data frame with columns for each sensor observations, columns of booleans for each sensor
indicating whether a calibration event may have occurred, and a column 'all_calib' that indicates if the
conditions were met for all sensors.
calib_dates_overlap: datetimes for which the conditions were met for a possible calibration event for
all sensors.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/calibration.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">calib_overlap</span><span class="p">(</span><span class="n">sensor_names</span><span class="p">,</span> <span class="n">input_array</span><span class="p">,</span> <span class="n">calib_params</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    calib_overlap seeks to identify calibration events by identifying where overlaps occur between multiple sensors.</span>
<span class="sd">    Calls the calib_detect function to identify events with a defined persistence length during certain days of the</span>
<span class="sd">    week (M-F) and hours of the day.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        sensor_names: list of sensors to be considered for overlap.</span>
<span class="sd">        input_array: array of data frames each with columns:</span>
<span class="sd">            'observed' of observed data</span>
<span class="sd">            'anomaly' booleans where True=1 corresponds to anomalies</span>
<span class="sd">            'persist_grp' with indices of persistent groups (output of the persist function)</span>
<span class="sd">        calib_params: parameters defined in the parameters file</span>
<span class="sd">            persist_high: longest length of the persistent group</span>
<span class="sd">            perist_low: shortest length of the persistent group</span>
<span class="sd">            hour_low: earliest hour for calibrations to have occurred</span>
<span class="sd">            hour_high: latest hour for calibrations to have occurred</span>
<span class="sd">    Returns:</span>
<span class="sd">        all_calib: array of data frames (one for each sensor) of booleans indicating whether the conditions were met</span>
<span class="sd">        for a possible calibration event.</span>
<span class="sd">        all_calib_dates: array of datetimes (one for each sensor) for which the conditions were met for a possible</span>
<span class="sd">        calibration event.</span>
<span class="sd">        df_all_calib: data frame with columns for each sensor observations, columns of booleans for each sensor</span>
<span class="sd">        indicating whether a calibration event may have occurred, and a column 'all_calib' that indicates if the</span>
<span class="sd">        conditions were met for all sensors.</span>
<span class="sd">        calib_dates_overlap: datetimes for which the conditions were met for a possible calibration event for</span>
<span class="sd">        all sensors.</span>
<span class="sd">    """</span>
    <span class="n">all_calib</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">all_calib_dates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">df_all_calib</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">input_array</span><span class="p">[</span><span class="n">sensor_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">df_all_calib</span><span class="p">[</span><span class="s1">'all_calib'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">snsr</span> <span class="ow">in</span> <span class="n">sensor_names</span><span class="p">:</span>
        <span class="n">calib</span><span class="p">,</span> <span class="n">calib_dates</span> <span class="o">=</span> <span class="n">calib_persist_detect</span><span class="p">(</span><span class="n">input_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">calib_params</span><span class="p">)</span>
        <span class="n">all_calib</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">calib</span>
        <span class="n">all_calib_dates</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">calib_dates</span>
        <span class="n">df_all_calib</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'observed'</span><span class="p">]</span>
        <span class="n">df_all_calib</span><span class="p">[</span><span class="n">snsr</span> <span class="o">+</span> <span class="s1">'_calib'</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_calib</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'anomaly'</span><span class="p">]</span>
        <span class="n">df_all_calib</span><span class="p">[</span><span class="n">snsr</span> <span class="o">+</span> <span class="s1">'_event'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">anomaly_events</span><span class="p">(</span><span class="n">df_all_calib</span><span class="p">[</span><span class="n">snsr</span> <span class="o">+</span> <span class="s1">'_calib'</span><span class="p">],</span> <span class="n">wf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">df_all_calib</span><span class="p">[</span><span class="s1">'all_calib'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df_all_calib</span><span class="p">[</span><span class="s1">'all_calib'</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df_all_calib</span><span class="p">[</span><span class="n">snsr</span> <span class="o">+</span> <span class="s1">'_event'</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">calib_dates_overlap</span> <span class="o">=</span> <span class="n">df_all_calib</span><span class="p">[</span><span class="n">df_all_calib</span><span class="p">[</span><span class="s1">'all_calib'</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span>

    <span class="k">return</span> <span class="n">all_calib</span><span class="p">,</span> <span class="n">all_calib_dates</span><span class="p">,</span> <span class="n">df_all_calib</span><span class="p">,</span> <span class="n">calib_dates_overlap</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.calibration.calib_persist_detect">

<code class="highlight language-python"><span class="n">calib_persist_detect</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">calib_params</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>calib_detect seeks to find calibration events based on 2 conditions: persistence of a defined length, which often occurs when sensors are out of the water, during certain days of the week (M-F) and times of the day.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with columns:
'observed' of observed data
'anomaly' booleans where True=1 corresponds to anomalies
'persist_grp' with indices of peristent groups (output of the persist function)</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>calib_params</code></td>
<td><code></code></td>
<td>
<p>parameters defined in the parameters file
persist_high: longest length of the persistent group
perist_low: shortest length of the persistent group
hour_low: earliest hour for calibrations to have occurred
hour_high: latest hour for calibrations to have occurred</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>calib</code></td>
<td>
<p>data frame of booleans indicating whether the conditions were met for a possible calibration event.
calib_dates: datetimes for which the conditions were met for a possible calibration event.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/calibration.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">calib_persist_detect</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">calib_params</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    calib_detect seeks to find calibration events based on 2 conditions: persistence of a defined length, which often occurs when sensors are out of the water, during certain days of the week (M-F) and times of the day.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with columns:</span>
<span class="sd">            'observed' of observed data</span>
<span class="sd">            'anomaly' booleans where True=1 corresponds to anomalies</span>
<span class="sd">            'persist_grp' with indices of peristent groups (output of the persist function)</span>
<span class="sd">        calib_params: parameters defined in the parameters file</span>
<span class="sd">            persist_high: longest length of the persistent group</span>
<span class="sd">            perist_low: shortest length of the persistent group</span>
<span class="sd">            hour_low: earliest hour for calibrations to have occurred</span>
<span class="sd">            hour_high: latest hour for calibrations to have occurred</span>
<span class="sd">    Returns:</span>
<span class="sd">        calib: data frame of booleans indicating whether the conditions were met for a possible calibration event.</span>
<span class="sd">        calib_dates: datetimes for which the conditions were met for a possible calibration event.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="s1">'persist_grp'</span> <span class="ow">in</span> <span class="n">df</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">'observed'</span><span class="p">,</span> <span class="s1">'anomaly'</span><span class="p">,</span> <span class="s1">'persist_grp'</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">][</span><span class="n">temp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">][</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">calib_params</span><span class="p">[</span><span class="s1">'persist_low'</span><span class="p">])</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">][</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">calib_params</span><span class="p">[</span><span class="s1">'persist_high'</span><span class="p">])):</span>
                <span class="n">temp</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">][</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">'observed'</span><span class="p">,</span> <span class="s1">'anomaly'</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">observed</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">anomaly_events</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">][</span><span class="n">temp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">][</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">calib_params</span><span class="p">[</span><span class="s1">'persist_low'</span><span class="p">])</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">][</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">calib_params</span><span class="p">[</span><span class="s1">'persist_high'</span><span class="p">])):</span>
                <span class="n">temp</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">][</span><span class="n">temp</span><span class="p">[</span><span class="s1">'persist_grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">dayofweek</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dayofweek</span>
    <span class="n">hour</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span>
    <span class="n">business</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[((</span><span class="n">dayofweek</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">dayofweek</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">dayofweek</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">dayofweek</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">dayofweek</span> <span class="o">==</span> <span class="mi">4</span><span class="p">))</span>
                         <span class="o">&amp;</span> <span class="p">(</span><span class="n">hour</span> <span class="o">&gt;=</span> <span class="n">calib_params</span><span class="p">[</span><span class="s1">'hour_low'</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">hour</span> <span class="o">&lt;=</span> <span class="n">calib_params</span><span class="p">[</span><span class="s1">'hour_high'</span><span class="p">])]</span>
    <span class="n">calib</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">temp</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">calib</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">calib</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">business</span><span class="p">[</span><span class="n">business</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">calib_dates</span> <span class="o">=</span> <span class="n">calib</span><span class="p">[</span><span class="n">calib</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span>

    <span class="k">return</span> <span class="n">calib</span><span class="p">,</span> <span class="n">calib_dates</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.calibration.find_gap">

<code class="highlight language-python"><span class="n">find_gap</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">calib_date</span><span class="p">,</span> <span class="n">hours</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">show_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>find_gap determines the gap value of a calibration event based on the largest single difference.
Uses a given time stamp and searches within a designated window. Accounts for large spikes
immediately following the difference.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>observed</code></td>
<td><code></code></td>
<td>
<p>time series of observations</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>calib_date</code></td>
<td><code></code></td>
<td>
<p>datetime for performing the correction</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>hours</code></td>
<td><code></code></td>
<td>
<p>window on each side of the calib_date to consider for finding the greatest difference. To use the exact datetime and not consider a window, use hours=0.</p>
</td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>show_shift</code></td>
<td><code></code></td>
<td>
<p>boolean indicating if subset used to determine the gap value should be output</p>
</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gap</code></td>
<td>
<p>the resulting value of the gap
end: the ending timestamp corresponding to applying the gap. Used as input to linear drift correction.
shifted: the subset of data used to determine the gap value with the gap applied</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/calibration.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">find_gap</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">calib_date</span><span class="p">,</span> <span class="n">hours</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">show_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    find_gap determines the gap value of a calibration event based on the largest single difference.</span>
<span class="sd">    Uses a given time stamp and searches within a designated window. Accounts for large spikes</span>
<span class="sd">    immediately following the difference.</span>
<span class="sd">    Args:</span>
<span class="sd">        observed: time series of observations</span>
<span class="sd">        calib_date: datetime for performing the correction</span>
<span class="sd">        hours: window on each side of the calib_date to consider for finding the greatest difference. To use the exact datetime and not consider a window, use hours=0.</span>
<span class="sd">        show_shift: boolean indicating if subset used to determine the gap value should be output</span>
<span class="sd">    Returns:</span>
<span class="sd">        gap: the resulting value of the gap</span>
<span class="sd">        end: the ending timestamp corresponding to applying the gap. Used as input to linear drift correction.</span>
<span class="sd">        shifted: the subset of data used to determine the gap value with the gap applied</span>

<span class="sd">    """</span>
    <span class="c1"># time window to consider</span>
    <span class="n">subset</span> <span class="o">=</span> <span class="n">observed</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
             <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">calib_date</span><span class="p">)</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="n">hours</span><span class="p">):</span>
             <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">calib_date</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="n">hours</span><span class="p">)</span>
             <span class="p">]</span>
    <span class="c1"># shift index by 1</span>
    <span class="n">shifted</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># timestamp of greatest difference</span>
    <span class="n">maxtime</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">diff</span><span class="p">())</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
    <span class="c1"># if the two subsequent signs are different, then add them together for the gap. This should address/eliminate</span>
    <span class="c1">#   spikes following the calibration.</span>
    <span class="k">if</span> <span class="n">subset</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">maxtime</span><span class="p">]</span> <span class="o">*</span> <span class="n">shifted</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">maxtime</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">maxtime</span><span class="p">]</span> <span class="o">+</span> <span class="n">shifted</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">maxtime</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">maxtime</span><span class="p">]</span>
    <span class="c1"># the last timestamp for the shift to occur</span>
    <span class="n">end</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shifted</span><span class="o">.</span><span class="n">diff</span><span class="p">())</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">show_shift</span><span class="p">:</span>
        <span class="c1"># shift subset to compare</span>
        <span class="n">shifted</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">subset</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">end</span><span class="p">]</span> <span class="o">+</span> <span class="n">gap</span>
        <span class="k">return</span> <span class="n">gap</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">shifted</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gap</span><span class="p">,</span> <span class="n">end</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.calibration.lin_drift_cor">

<code class="highlight language-python"><span class="n">lin_drift_cor</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">gap</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>lin_drift_cor performs linear drift correction on data. Typical correction for calibration events. This function operates on the basis of a single event.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>observed</code></td>
<td><code></code></td>
<td>
<p>time series of observations</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>start</code></td>
<td><code></code></td>
<td>
<p>datetime for the beginning of the correction</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>end</code></td>
<td><code></code></td>
<td>
<p>datetime for the end of the correction</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>gap</code></td>
<td><code></code></td>
<td>
<p>gap value that determines the degree of the shift, which occurs at the end date.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>replace</code></td>
<td><code></code></td>
<td>
<p>indicates whether the values of the correction should replace the associated values in the data frame</p>
</td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>result</code></td>
<td>
<p>data frame of corrected values
observed: time series of observations with corrected values if replace was selected</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/calibration.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">lin_drift_cor</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">gap</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">   lin_drift_cor performs linear drift correction on data. Typical correction for calibration events. This function operates on the basis of a single event.</span>
<span class="sd">   Arguments:</span>
<span class="sd">       observed: time series of observations</span>
<span class="sd">       start: datetime for the beginning of the correction</span>
<span class="sd">       end: datetime for the end of the correction</span>
<span class="sd">       gap: gap value that determines the degree of the shift, which occurs at the end date.</span>
<span class="sd">       replace: indicates whether the values of the correction should replace the associated values in the data frame</span>
<span class="sd">   Returns:</span>
<span class="sd">       result: data frame of corrected values</span>
<span class="sd">       observed: time series of observations with corrected values if replace was selected</span>
<span class="sd">    """</span>
    <span class="c1"># todo: ignore - 9999 values</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">observed</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">'ldc'</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">observed</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])):</span>
        <span class="c1"># y = original_value[i] - i * gap / total_num_points</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">observed</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">observed</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">gap</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">observed</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">'ldc'</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
        <span class="n">observed</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">'ldc'</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">observed</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<h2 id="utilities-functions-module-anomaly_utilities">Utilities Functions (module: anomaly_utilities)</h2>
<div class="doc doc-object doc-module">
<h2 class="hidden-toc" id="PyHydroQC.anomaly_utilities" style="visibility: hidden; position: absolute;">
        </h2>
<div class="doc doc-contents first">
<div class="doc doc-children">
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.aggregate_results">

<code class="highlight language-python"><span class="n">aggregate_results</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">models</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compare</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>aggregate_results combines the assessments of detections from multiple models to give a single output of anomalies.
If any model detects an anomaly, the point is labeled as anomalous.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with required column 'observed' of observed data values.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>models</code></td>
<td><code></code></td>
<td>
<p>dictionary of model outputs consisting of dataframes with the required column 'detected_event' of booleans indicating anomalies.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>verbose</code></td>
<td><code></code></td>
<td>
<p>if True, includes columns for each model type in the output.</p>
</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>compare</code></td>
<td><code></code></td>
<td>
<p>if True, includes columns for technician labeled anomalies and labeled events in the output (as gathered from the input df) for determination of metrics.</p>
</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>results_all</code></td>
<td>
<p>data frame containing columns 'detected_event' of booleans representing anomalies aggregated
from all of the models and 'observed' of observed values.
    Additional columns are added if verbose and compare options are selected.
metrics_all: if compare is selected, then metrics are output for the aggregate anomalies.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">aggregate_results</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">models</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compare</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    aggregate_results combines the assessments of detections from multiple models to give a single output of anomalies.</span>
<span class="sd">    If any model detects an anomaly, the point is labeled as anomalous.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with required column 'observed' of observed data values.</span>
<span class="sd">        models: dictionary of model outputs consisting of dataframes with the required column 'detected_event' of booleans indicating anomalies.</span>
<span class="sd">        verbose: if True, includes columns for each model type in the output.</span>
<span class="sd">        compare: if True, includes columns for technician labeled anomalies and labeled events in the output (as gathered from the input df) for determination of metrics.</span>
<span class="sd">    Returns:</span>
<span class="sd">        results_all: data frame containing columns 'detected_event' of booleans representing anomalies aggregated</span>
<span class="sd">        from all of the models and 'observed' of observed values.</span>
<span class="sd">            Additional columns are added if verbose and compare options are selected.</span>
<span class="sd">        metrics_all: if compare is selected, then metrics are output for the aggregate anomalies.</span>
<span class="sd">    """</span>
    <span class="n">results_all</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
        <span class="n">results_all</span><span class="p">[</span><span class="n">model</span><span class="p">]</span> <span class="o">=</span> <span class="n">models</span><span class="p">[</span><span class="n">model</span><span class="p">][</span><span class="s1">'detected_event'</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">results_all</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">]</span> <span class="o">=</span> <span class="n">results_all</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">results_all</span><span class="p">[</span><span class="s1">'observed'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'observed'</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="n">results_all</span> <span class="o">=</span> <span class="n">results_all</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">compare</span><span class="p">:</span>
        <span class="n">results_all</span><span class="p">[</span><span class="s1">'labeled_anomaly'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'labeled_anomaly'</span><span class="p">]</span>
        <span class="n">results_all</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_events</span><span class="p">(</span><span class="n">results_all</span><span class="p">[</span><span class="s1">'labeled_anomaly'</span><span class="p">],</span> <span class="n">wf</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">compare_events</span><span class="p">(</span><span class="n">results_all</span><span class="p">,</span> <span class="n">wf</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">metrics_all</span> <span class="o">=</span> <span class="n">metrics</span><span class="p">(</span><span class="n">results_all</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results_all</span><span class="p">,</span> <span class="n">metrics_all</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">results_all</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.anomaly_events">

<code class="highlight language-python"><span class="n">anomaly_events</span><span class="p">(</span><span class="n">anomaly</span><span class="p">,</span> <span class="n">wf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>anomaly_events groups consecutively labeled data points as anomalous events by adding an index.
Events may also be widened.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>anomaly</code></td>
<td><code></code></td>
<td>
<p>boolean series of labeled or detected anomalies where True (1) = anomalous data point.
e.g., 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 1 0 0 0 1 1 1 1</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>wf</code></td>
<td><code></code></td>
<td>
<p>positive integer, a widening factor that is used to determine how much to widen each event
before and after the true values. Default = 1 adds a single anomalous point before/after the labeled point.</p>
</td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>sf</code></td>
<td><code></code></td>
<td>
<p>ratio between 0.0-1.0. a significance factor used to warn user when an event size is greater
than this ratio compared to the entire data set. Default = 0.05 = 5%.</p>
</td>
<td><code>0.05</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>event</code></td>
<td>
<p>integer series of enumerated event labels corresponding to each widened group of consecutive anomalous points.
e.g., 0 0 0 1 1 1 1 1 1 0 0 0 0 0 2 2 2 2 2 0 3 3 3 0 4 4 4 4 4</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">anomaly_events</span><span class="p">(</span><span class="n">anomaly</span><span class="p">,</span> <span class="n">wf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    anomaly_events groups consecutively labeled data points as anomalous events by adding an index.</span>
<span class="sd">    Events may also be widened.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        anomaly: boolean series of labeled or detected anomalies where True (1) = anomalous data point.</span>
<span class="sd">            e.g., 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 1 0 0 0 1 1 1 1</span>
<span class="sd">        wf: positive integer, a widening factor that is used to determine how much to widen each event</span>
<span class="sd">            before and after the true values. Default = 1 adds a single anomalous point before/after the labeled point.</span>
<span class="sd">        sf: ratio between 0.0-1.0. a significance factor used to warn user when an event size is greater</span>
<span class="sd">            than this ratio compared to the entire data set. Default = 0.05 = 5%.</span>
<span class="sd">    Returns:</span>
<span class="sd">        event: integer series of enumerated event labels corresponding to each widened group of consecutive anomalous points.</span>
<span class="sd">        e.g., 0 0 0 1 1 1 1 1 1 0 0 0 0 0 2 2 2 2 2 0 3 3 3 0 4 4 4 4 4</span>
<span class="sd">    """</span>
    <span class="c1"># initialize event variables</span>
    <span class="n">event_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">event</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># handle the first wf data points in the entire time series</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">wf</span><span class="p">):</span>
        <span class="n">event</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># search through data assigning each point an event (positive integer) or 0 for points not belonging to an event</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wf</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">anomaly</span><span class="p">)</span> <span class="o">-</span> <span class="n">wf</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">anomaly</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">wf</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">wf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># if there are anomalies within the wf window</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># if event is empty</span>
                <span class="n">event_count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># increment the event counter</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># if the last event value is 0, then a new event has been encountered</span>
                <span class="n">event_count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># increment the event counter</span>
            <span class="n">event</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event_count</span><span class="p">)</span>  <span class="c1"># append the event array with the current event number</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># no anomalies are within the wf window</span>
            <span class="n">event</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># this data point does not belong to an event, append 0</span>

    <span class="c1"># handle the last wf data points in the entire time series</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">wf</span><span class="p">):</span>
        <span class="n">event</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># determine if an event is greater than the significance factor</span>
    <span class="n">event_values</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">event</span><span class="p">)</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">event_values</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">event_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">sf</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">event</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"WARNING: an event was found to be greater than the significance factor!"</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">event</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.assign_cm">

<code class="highlight language-python"><span class="n">assign_cm</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="n">wf</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>assign_cm is a simple helper function used in compare_events</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>val</code></td>
<td><code></code></td>
<td>
<p>string value to specify which area of the confusion matrix this point belongs to: 'tp', 'fp', or 'fn'</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>len</code></td>
<td><code></code></td>
<td>
<p>how long the total array should be</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>wf</code></td>
<td><code></code></td>
<td>
<p>integer widening factor that determines how many points should be turned into 'tn' on both edges</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cm</code></td>
<td>
<p>series of length len, with wf 'tn' at the beginning and the end filed with val in between</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">assign_cm</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="n">wf</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    assign_cm is a simple helper function used in compare_events</span>
<span class="sd">    Arguments:</span>
<span class="sd">        val: string value to specify which area of the confusion matrix this point belongs to: 'tp', 'fp', or 'fn'</span>
<span class="sd">        len: how long the total array should be</span>
<span class="sd">        wf: integer widening factor that determines how many points should be turned into 'tn' on both edges</span>
<span class="sd">    Returns:</span>
<span class="sd">        cm: series of length len, with wf 'tn' at the beginning and the end filed with val in between</span>
<span class="sd">    """</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'tn'</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wf</span><span class="p">,</span> <span class="nb">len</span> <span class="o">-</span> <span class="n">wf</span><span class="p">):</span>
        <span class="n">cm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">cm</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.compare_events">

<code class="highlight language-python"><span class="n">compare_events</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">wf</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>compare_events compares anomalous events that are technician labeled and machine detected.
Labeled and detected data may have been widened to increase the window of overlap.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>wf</code></td>
<td><code></code></td>
<td>
<p>integer widening factor used when generating events</p>
</td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with required columns:
'labeled_anomaly': series of booleans based on expert labeled anomalies.
'detected_anomaly': series of machine detected anomaly booleans based on modeling.
'labeled_event': series of numbered events based on expert labeled anomalies
(output of anomaly_events function).
'detected_event': series of numbered events based on machine detected anomalies
(output of anomaly_events function).</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td>
<p>orginal data frame with additional columns:
    'grp': a new column representing the indices of event groups.
    'conf_mtx': a new column that gives the confusion matrix value for each data point.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">compare_events</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">wf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    compare_events compares anomalous events that are technician labeled and machine detected.</span>
<span class="sd">    Labeled and detected data may have been widened to increase the window of overlap.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        wf: integer widening factor used when generating events</span>
<span class="sd">        df: data frame with required columns:</span>
<span class="sd">            'labeled_anomaly': series of booleans based on expert labeled anomalies.</span>
<span class="sd">            'detected_anomaly': series of machine detected anomaly booleans based on modeling.</span>
<span class="sd">            'labeled_event': series of numbered events based on expert labeled anomalies</span>
<span class="sd">            (output of anomaly_events function).</span>
<span class="sd">            'detected_event': series of numbered events based on machine detected anomalies</span>
<span class="sd">            (output of anomaly_events function).</span>
<span class="sd">    Returns:</span>
<span class="sd">        df: orginal data frame with additional columns:</span>
<span class="sd">            'grp': a new column representing the indices of event groups.</span>
<span class="sd">            'conf_mtx': a new column that gives the confusion matrix value for each data point.</span>
<span class="sd">    """</span>

    <span class="c1"># initialize variables</span>
    <span class="n">grp_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># initialize to error flag</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'tn'</span>
    <span class="n">prev_la</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">prev_da</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">prev_gi</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">])):</span>  <span class="c1"># for every row of data</span>

        <span class="c1"># if this row is an event transition case</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev_la</span> <span class="o">!=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">prev_da</span> <span class="o">!=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">][</span><span class="n">i</span><span class="p">]):</span>

            <span class="c1"># if coming from a true negative case</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prev_la</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">prev_da</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">grp_idx</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># if entering a true negative case</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">df</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">grp_idx</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># if it's a complete flip-flop case</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">prev_la</span> <span class="o">!=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">prev_da</span> <span class="o">!=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">][</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">grp_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">grp_idx</span>  <span class="c1"># update the group index for this row</span>

        <span class="c1"># if this row is a group transition</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grp_idx</span> <span class="o">!=</span> <span class="n">prev_gi</span><span class="p">):</span>
            <span class="c1"># add confusion matrix category to previous group</span>

            <span class="c1"># if this event group is both labeled and detected as anomalous case</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">][</span><span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_gi</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">][</span><span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_gi</span><span class="p">])):</span>
                <span class="c1"># True Positive group</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_gi</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_cm</span><span class="p">(</span><span class="s1">'tp'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_gi</span><span class="p">]),</span> <span class="n">wf</span><span class="p">)</span>
            <span class="c1"># if this event group is detected as anomalous but not labeled</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">][</span><span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_gi</span><span class="p">])):</span>
                <span class="c1"># False Positive group</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_gi</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_cm</span><span class="p">(</span><span class="s1">'fp'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_gi</span><span class="p">]),</span> <span class="n">wf</span><span class="p">)</span>
            <span class="c1"># if this event group is labeled as anomalous but not detected</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">][</span><span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_gi</span><span class="p">])):</span>
                <span class="c1"># False Negative group</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_gi</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_cm</span><span class="p">(</span><span class="s1">'fn'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'grp'</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_gi</span><span class="p">]),</span> <span class="n">wf</span><span class="p">)</span>

        <span class="c1"># update previous state variables</span>
        <span class="n">prev_la</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">prev_da</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">prev_gi</span> <span class="o">=</span> <span class="n">grp_idx</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">'grp'</span><span class="p">)</span>  <span class="c1"># delete group index column</span>

    <span class="k">return</span> <span class="n">df</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.detect_anomalies">

<code class="highlight language-python"><span class="n">detect_anomalies</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">residuals</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>detect_anomalies compares model residuals to thresholds to determine which points are anomalous.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>observed</code></td>
<td><code></code></td>
<td>
<p>data frame or series of observed data.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>predictions</code></td>
<td><code></code></td>
<td>
<p>series of model predictions.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>residuals</code></td>
<td><code></code></td>
<td>
<p>series of model residuals.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>threshold</code></td>
<td><code></code></td>
<td>
<p>data frame with the columns 'lower' and 'upper' corresponding to the acceptable range of the residual.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>summary</code></td>
<td><code></code></td>
<td>
<p>if True, will print the ratio of detections.</p>
</td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>detections</code></td>
<td>
<p>data frame with columns for observations, predictions, residuals, anomalies
(boolean where True (1) = anomalous data point)</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">detect_anomalies</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">residuals</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    detect_anomalies compares model residuals to thresholds to determine which points are anomalous.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        observed: data frame or series of observed data.</span>
<span class="sd">        predictions: series of model predictions.</span>
<span class="sd">        residuals: series of model residuals.</span>
<span class="sd">        threshold: data frame with the columns 'lower' and 'upper' corresponding to the acceptable range of the residual.</span>
<span class="sd">        summary: if True, will print the ratio of detections.</span>
<span class="sd">    Returns:</span>
<span class="sd">        detections: data frame with columns for observations, predictions, residuals, anomalies</span>
<span class="sd">        (boolean where True (1) = anomalous data point)</span>
<span class="sd">    """</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>
    <span class="n">detections</span><span class="p">[</span><span class="s1">'prediction'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
    <span class="n">detections</span><span class="p">[</span><span class="s1">'residual'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
    <span class="n">detections</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">detections</span><span class="p">[</span><span class="s1">'residual'</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">[</span><span class="s1">'low'</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">threshold</span><span class="p">[</span><span class="s1">'high'</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">detections</span><span class="p">[</span><span class="s1">'residual'</span><span class="p">])</span>
    <span class="c1"># anomalies = test_score_df[test_score_df.anomaly == True]</span>

    <span class="c1"># output summary</span>
    <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'ratio of detections: </span><span class="si">%f</span><span class="s1">'</span> <span class="o">%</span> <span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="n">detections</span><span class="o">.</span><span class="n">anomaly</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">detections</span><span class="o">.</span><span class="n">anomaly</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">),</span> <span class="s1">'%'</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">detections</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.detect_anomalies_cons">

<code class="highlight language-python"><span class="n">detect_anomalies_cons</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>Compares residuals to a constant threshold to identify anomalies. Can use set threshold level or threshold
determined by set_cons_threshold function.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>residuals</code></td>
<td><code></code></td>
<td>
<p>series of model residuals.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>threshold</code></td>
<td><code></code></td>
<td>
<p>constant threshold value.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>summary</code></td>
<td><code></code></td>
<td>
<p>if True, will print the ratio of detections.</p>
</td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>detected_anomaly</code></td>
<td>
<p>boolean series where True (1) = anomalous data point</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">detect_anomalies_cons</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Compares residuals to a constant threshold to identify anomalies. Can use set threshold level or threshold</span>
<span class="sd">    determined by set_cons_threshold function.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        residuals: series of model residuals.</span>
<span class="sd">        threshold: constant threshold value.</span>
<span class="sd">        summary: if True, will print the ratio of detections.</span>
<span class="sd">    Returns:</span>
<span class="sd">        detected_anomaly: boolean series where True (1) = anomalous data point</span>
<span class="sd">    """</span>
    <span class="c1"># DETERMINE ANOMALIES</span>
    <span class="n">detected_anomaly</span> <span class="o">=</span> <span class="p">(</span><span class="n">residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">[</span><span class="s1">'low'</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">threshold</span><span class="p">[</span><span class="s1">'high'</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># gives bools</span>
    <span class="c1"># output summary</span>
    <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'ratio of detections: </span><span class="si">%f</span><span class="s1">'</span> <span class="o">%</span> <span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="n">detected_anomaly</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">detected_anomaly</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">),</span> <span class="s1">'%'</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">detected_anomaly</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.event_metrics">

<code class="highlight language-python"><span class="n">event_metrics</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>event_metrics calculates an alternative set of metrics where every event is treated with equal weight
regardless of size.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with required columns:
'conf_mtx': strings corresponding to confusion matrix categories: tp, tn, fp, fn</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>true_positives</code></td>
<td>
<p>count of valid detection events.
false_negatives: count of missed events.
false_positives: count of incorrect detections.
prc: precision of detections.
npv: negative predicted value.
acc: accuracy of detections.
rcl: recall of detections.
f1: statistic that balances true positives and false negatives.
f2: statistic that gives more weight to true positives.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">event_metrics</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    event_metrics calculates an alternative set of metrics where every event is treated with equal weight</span>
<span class="sd">    regardless of size.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with required columns:</span>
<span class="sd">            'conf_mtx': strings corresponding to confusion matrix categories: tp, tn, fp, fn</span>
<span class="sd">    Returns:</span>
<span class="sd">        true_positives: count of valid detection events.</span>
<span class="sd">        false_negatives: count of missed events.</span>
<span class="sd">        false_positives: count of incorrect detections.</span>
<span class="sd">        prc: precision of detections.</span>
<span class="sd">        npv: negative predicted value.</span>
<span class="sd">        acc: accuracy of detections.</span>
<span class="sd">        rcl: recall of detections.</span>
<span class="sd">        f1: statistic that balances true positives and false negatives.</span>
<span class="sd">        f2: statistic that gives more weight to true positives.</span>
<span class="sd">    """</span>
    <span class="n">metrics</span> <span class="o">=</span> <span class="n">MetricsContainer</span><span class="p">()</span>
    <span class="n">tp_events</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fp_events</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fn_events</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">prev_cm</span> <span class="o">=</span> <span class="s1">'tn'</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">])):</span>  <span class="c1"># for every row of data</span>

        <span class="c1"># if the confusion matrix class has changed</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">prev_cm</span><span class="p">):</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'tp'</span><span class="p">):</span>  <span class="c1"># true positive case</span>
                <span class="n">tp_events</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'fp'</span><span class="p">):</span>  <span class="c1"># false positive case</span>
                <span class="n">fp_events</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'fn'</span><span class="p">):</span>  <span class="c1"># false negative case</span>
                <span class="n">fn_events</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">prev_cm</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># calculate metrics</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">true_positives</span> <span class="o">=</span> <span class="n">tp_events</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">false_positives</span> <span class="o">=</span> <span class="n">fp_events</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">false_negatives</span> <span class="o">=</span> <span class="n">fn_events</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">prc</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">ppv</span> <span class="o">=</span> <span class="n">tp_events</span> <span class="o">/</span> <span class="p">(</span><span class="n">tp_events</span> <span class="o">+</span> <span class="n">fp_events</span><span class="p">)</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">rcl</span> <span class="o">=</span> <span class="n">tp_events</span> <span class="o">/</span> <span class="p">(</span><span class="n">tp_events</span> <span class="o">+</span> <span class="n">fn_events</span><span class="p">)</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">f1</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">prc</span> <span class="o">*</span> <span class="n">metrics</span><span class="o">.</span><span class="n">rcl</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">prc</span> <span class="o">+</span> <span class="n">metrics</span><span class="o">.</span><span class="n">rcl</span><span class="p">)</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">f2</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="o">*</span> <span class="n">tp_events</span> <span class="o">/</span> \
                 <span class="p">(</span><span class="mf">5.0</span> <span class="o">*</span> <span class="n">tp_events</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">fn_events</span> <span class="o">+</span> <span class="n">fp_events</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">metrics</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.get_data">

<code class="highlight language-python"><span class="n">get_data</span><span class="p">(</span><span class="n">sensors</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">site</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">years</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>get_data imports time series data from csv files. Files may specified explicitly by file name, or a series of files
may be imported that follow a naming pattern with site and year (e.g. "MainStreet2014.csv").
Files should have columns corresponding to each sensor. If technician labels and corrections exist, they may be
imported by naming columns sensor_cor and labeled_anomaly.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sensors</code></td>
<td><code></code></td>
<td>
<p>list of name(s) of the sensor/variable data of interest. These must be the column names in data file(s).</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>filename</code></td>
<td><code></code></td>
<td>
<p>string of the file name containing input data</p>
</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>site</code></td>
<td><code></code></td>
<td>
<p>string of name of the data collection site</p>
</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>years</code></td>
<td><code></code></td>
<td>
<p>list of the year(s) of interest</p>
</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>path</code></td>
<td><code></code></td>
<td>
<p>path to .csv files containing the data of interest</p>
</td>
<td><code>''</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sensor_array</code></td>
<td>
<p>array of pandas DataFrames, each with 3 columns for the variable/sensor of interest:
'raw', 'cor', 'labeled_anomaly'.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">sensors</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">""</span><span class="p">,</span> <span class="n">site</span><span class="o">=</span><span class="s2">""</span><span class="p">,</span> <span class="n">years</span><span class="o">=</span><span class="s2">""</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">""</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    get_data imports time series data from csv files. Files may specified explicitly by file name, or a series of files</span>
<span class="sd">    may be imported that follow a naming pattern with site and year (e.g. "MainStreet2014.csv").</span>
<span class="sd">    Files should have columns corresponding to each sensor. If technician labels and corrections exist, they may be</span>
<span class="sd">    imported by naming columns sensor_cor and labeled_anomaly.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        sensors: list of name(s) of the sensor/variable data of interest. These must be the column names in data file(s).</span>
<span class="sd">        filename: string of the file name containing input data</span>
<span class="sd">        site: string of name of the data collection site</span>
<span class="sd">        years: list of the year(s) of interest</span>
<span class="sd">        path: path to .csv files containing the data of interest</span>
<span class="sd">    Returns:</span>
<span class="sd">        sensor_array: array of pandas DataFrames, each with 3 columns for the variable/sensor of interest:</span>
<span class="sd">        'raw', 'cor', 'labeled_anomaly'.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s2">""</span><span class="p">:</span>  <span class="c1"># use default directory when none is provided</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="s2">"/"</span>  <span class="c1"># default directory is ./</span>
    <span class="n">df_full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>  <span class="c1"># start with empty dataframe and concatenate each file</span>

    <span class="k">if</span> <span class="n">filename</span><span class="p">:</span>
        <span class="n">df_full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="n">filename</span><span class="p">,</span>
                              <span class="n">skipinitialspace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">engine</span><span class="o">=</span><span class="s1">'python'</span><span class="p">,</span>
                              <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                              <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                              <span class="n">parse_dates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">infer_datetime_format</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">years</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">yr</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>  <span class="c1"># loop over each file</span>
            <span class="n">df_year</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="n">site</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">yr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">".csv"</span><span class="p">,</span>
                                  <span class="n">skipinitialspace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">engine</span><span class="o">=</span><span class="s1">'python'</span><span class="p">,</span>
                                  <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                  <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                  <span class="n">parse_dates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">infer_datetime_format</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">df_full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df_full</span><span class="p">,</span> <span class="n">df_year</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># create data frames with raw, corrected, and labeled data (if the corrected and labeled data exist)</span>
    <span class="n">sensor_array</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">snsr</span> <span class="ow">in</span> <span class="n">sensors</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">df_full</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">'raw'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_full</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span>

        <span class="c1"># if corrected data is available in dataset</span>
        <span class="k">if</span> <span class="n">snsr</span> <span class="o">+</span> <span class="s1">'_cor'</span> <span class="ow">in</span> <span class="n">df_full</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">'cor'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_full</span><span class="p">[</span><span class="n">snsr</span> <span class="o">+</span> <span class="s1">'_cor'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">snsr</span> <span class="o">+</span> <span class="s2">"_qual"</span> <span class="ow">in</span> <span class="n">df_full</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">'labeled_anomaly'</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">df_full</span><span class="p">[</span><span class="n">snsr</span> <span class="o">+</span> <span class="s1">'_qual'</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>
        <span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>

    <span class="k">return</span> <span class="n">sensor_array</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.group_bools">

<code class="highlight language-python"><span class="n">group_bools</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_in</span><span class="p">,</span> <span class="n">column_out</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>group_bools indexes each grouping of anomalies (1) and valid points (0) as numbered sets.
Used for anomaly correction.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with required columns:
'detected_event': boolean array of classified data points</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td>
<p>original data frame with additional column:
    'group' containing an index of boolean groupings</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">group_bools</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_in</span><span class="p">,</span> <span class="n">column_out</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    group_bools indexes each grouping of anomalies (1) and valid points (0) as numbered sets.</span>
<span class="sd">    Used for anomaly correction.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with required columns:</span>
<span class="sd">            'detected_event': boolean array of classified data points</span>
<span class="sd">    Returns:</span>
<span class="sd">        df: original data frame with additional column:</span>
<span class="sd">            'group' containing an index of boolean groupings</span>
<span class="sd">    """</span>
    <span class="c1"># initialize the 'group' column to zeros</span>
    <span class="n">df</span><span class="p">[</span><span class="n">column_out</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># initialize placeholder for boolean state of previous group</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">column_in</span><span class="p">]</span>
    <span class="c1"># initialize the group index to zero</span>
    <span class="n">gi</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># loop over every row in dataframe</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_out</span><span class="p">])):</span>

        <span class="c1"># if the anomaly bool has changed</span>
        <span class="k">if</span> <span class="n">last</span> <span class="o">!=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">column_in</span><span class="p">]:</span>
            <span class="n">gi</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># increment the group index</span>
        <span class="c1"># assign this row to the group index</span>
        <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">column_out</span><span class="p">)]</span> <span class="o">=</span> <span class="n">gi</span>

        <span class="c1"># update last boolean state</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">column_in</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">df</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.metrics">

<code class="highlight language-python"><span class="n">metrics</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>metrics evaluates the performance of anomaly detection comparing detected anomalies to technician labeled anomalies.
Output is contained in an object of the class MetricsContainer.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with required column:
'conf_mtx': strings corresponding to confusion matrix categories: tp, tn, fp, fn</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>true_positives</code></td>
<td>
<p>count of data points from valid detections.
false_negatives: count of data points from missed events.
false_positives: count of data points from incorrect detections.
true_negatives: count of valid undetected data.
prc: is the precision of detections.
npv: negative predicted value.
acc: accuracy of detections.
rcl: recall of detections.
f1: statistic that balances true positives and false negatives.
f2: statistic that gives more weight to true positives.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">metrics</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    metrics evaluates the performance of anomaly detection comparing detected anomalies to technician labeled anomalies.</span>
<span class="sd">    Output is contained in an object of the class MetricsContainer.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with required column:</span>
<span class="sd">            'conf_mtx': strings corresponding to confusion matrix categories: tp, tn, fp, fn</span>
<span class="sd">    Returns:</span>
<span class="sd">        true_positives: count of data points from valid detections.</span>
<span class="sd">        false_negatives: count of data points from missed events.</span>
<span class="sd">        false_positives: count of data points from incorrect detections.</span>
<span class="sd">        true_negatives: count of valid undetected data.</span>
<span class="sd">        prc: is the precision of detections.</span>
<span class="sd">        npv: negative predicted value.</span>
<span class="sd">        acc: accuracy of detections.</span>
<span class="sd">        rcl: recall of detections.</span>
<span class="sd">        f1: statistic that balances true positives and false negatives.</span>
<span class="sd">        f2: statistic that gives more weight to true positives.</span>
<span class="sd">    """</span>
    <span class="n">metrics</span> <span class="o">=</span> <span class="n">MetricsContainer</span><span class="p">()</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">true_positives</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'tp'</span><span class="p">])</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">false_negatives</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'fn'</span><span class="p">])</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">false_positives</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'fp'</span><span class="p">])</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">true_negatives</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">][</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'tn'</span><span class="p">])</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">prc</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">ppv</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">true_positives</span> <span class="o">/</span> <span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">true_positives</span> <span class="o">+</span> <span class="n">metrics</span><span class="o">.</span><span class="n">false_positives</span><span class="p">)</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">npv</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">true_negatives</span> <span class="o">/</span> <span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">true_negatives</span> <span class="o">+</span> <span class="n">metrics</span><span class="o">.</span><span class="n">false_negatives</span><span class="p">)</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">acc</span> <span class="o">=</span> <span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">true_positives</span> <span class="o">+</span> <span class="n">metrics</span><span class="o">.</span><span class="n">true_negatives</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'conf_mtx'</span><span class="p">])</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">rcl</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">true_positives</span> <span class="o">/</span> <span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">true_positives</span> <span class="o">+</span> <span class="n">metrics</span><span class="o">.</span><span class="n">false_negatives</span><span class="p">)</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">f1</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">prc</span> <span class="o">*</span> <span class="n">metrics</span><span class="o">.</span><span class="n">rcl</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">prc</span> <span class="o">+</span> <span class="n">metrics</span><span class="o">.</span><span class="n">rcl</span><span class="p">)</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">f2</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="o">*</span> <span class="n">metrics</span><span class="o">.</span><span class="n">true_positives</span> <span class="o">/</span> \
                 <span class="p">(</span><span class="mf">5.0</span> <span class="o">*</span> <span class="n">metrics</span><span class="o">.</span><span class="n">true_positives</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">metrics</span><span class="o">.</span><span class="n">false_negatives</span> <span class="o">+</span> <span class="n">metrics</span><span class="o">.</span><span class="n">false_positives</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">metrics</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.set_cons_threshold">

<code class="highlight language-python"><span class="n">set_cons_threshold</span><span class="p">(</span><span class="n">model_fit</span><span class="p">,</span> <span class="n">alpha_in</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>set_cons_threshold determines a threshold based on confidence interval and specified alpha for an ARIMA model.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model_fit</code></td>
<td><code></code></td>
<td>
<p>SARIMAX model object.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>alpha_in</code></td>
<td><code></code></td>
<td>
<p>scalar between 0 and 1 representing the acceptable uncertainty.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>threshold</code></td>
<td>
<p>single value.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">set_cons_threshold</span><span class="p">(</span><span class="n">model_fit</span><span class="p">,</span> <span class="n">alpha_in</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    set_cons_threshold determines a threshold based on confidence interval and specified alpha for an ARIMA model.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        model_fit: SARIMAX model object.</span>
<span class="sd">        alpha_in: scalar between 0 and 1 representing the acceptable uncertainty.</span>
<span class="sd">    Returns:</span>
<span class="sd">        threshold: single value.</span>
<span class="sd">    """</span>
    <span class="n">predict</span> <span class="o">=</span> <span class="n">model_fit</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">()</span>
    <span class="n">predict_ci</span> <span class="o">=</span> <span class="n">predict</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha_in</span><span class="p">)</span>
    <span class="n">predict_ci</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"lower"</span><span class="p">,</span> <span class="s2">"upper"</span><span class="p">]</span>
    <span class="n">predict_ci</span><span class="p">[</span><span class="s2">"lower"</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">predict_ci</span><span class="p">[</span><span class="s2">"lower"</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># This gives a constant interval for all points.</span>
    <span class="c1"># Could also try a threshold to maximize F2, but that requires having labeled data. Could base on a portion of data?</span>
    <span class="n">thresholds</span> <span class="o">=</span> <span class="n">predict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">predict_ci</span><span class="p">[</span><span class="s2">"lower"</span><span class="p">]</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">threshold</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.set_dynamic_threshold">

<code class="highlight language-python"><span class="n">set_dynamic_threshold</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">window_sz</span><span class="o">=</span><span class="mi">96</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">min_range</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>set_dynamic_threshold determines a threshold for each point based on the local confidence interval
considering the model residuals looking forward and backward a specified number of steps.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>residuals</code></td>
<td><code></code></td>
<td>
<p>series like object or a data frame of model residuals.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>alpha</code></td>
<td><code></code></td>
<td>
<p>scalar between 0 and 1 representing the acceptable uncertainty.</p>
</td>
<td><code>0.01</code></td>
</tr>
<tr>
<td><code>window_sz</code></td>
<td><code></code></td>
<td>
<p>integer representing how many data points to use in both directions.
default = 96 for one day for 15-minute data.</p>
</td>
<td><code>96</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>threshold</code></td>
<td>
<p>data frame of columns of low and high threshold values.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">set_dynamic_threshold</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">window_sz</span><span class="o">=</span><span class="mi">96</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">min_range</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    set_dynamic_threshold determines a threshold for each point based on the local confidence interval</span>
<span class="sd">    considering the model residuals looking forward and backward a specified number of steps.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        residuals: series like object or a data frame of model residuals.</span>
<span class="sd">        alpha: scalar between 0 and 1 representing the acceptable uncertainty.</span>
<span class="sd">        window_sz: integer representing how many data points to use in both directions.</span>
<span class="sd">            default = 96 for one day for 15-minute data.</span>
<span class="sd">    Returns:</span>
<span class="sd">        threshold: data frame of columns of low and high threshold values.</span>
<span class="sd">    """</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># initialize empty list to hold thresholds</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># if the window size parameter is too big for this data set</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">window_sz</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">residuals</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"WARNING: in set_dynamic_threshold(), window_sz &gt; len(data)! Reducing window_sz."</span><span class="p">)</span>
        <span class="n">window_sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>  <span class="c1"># reduce the window to the max allowable</span>

    <span class="c1"># loop through data and add each threshold pair</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">residuals</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">window_sz</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">):</span>  <span class="c1"># index is closer than window size to left edge of data</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># look back as far as the window size</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">window_sz</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">window_sz</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">residuals</span><span class="p">)):</span>  <span class="c1"># index is close to right edge of data</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># look forward as far as the window size</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">window_sz</span>

        <span class="c1"># calculate the range of probable values using given alpha</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">residuals</span><span class="p">[</span><span class="n">lo</span><span class="p">:(</span><span class="n">hi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">residuals</span><span class="p">[</span><span class="n">lo</span><span class="p">:(</span><span class="n">hi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="n">th_range</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">sigma</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">th_range</span> <span class="o">&lt;</span> <span class="n">min_range</span><span class="p">):</span>
            <span class="n">th_range</span> <span class="o">=</span> <span class="n">min_range</span>
        <span class="c1"># append pair of upper and lower thresholds</span>
        <span class="n">threshold</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mean</span> <span class="o">-</span> <span class="n">th_range</span><span class="p">,</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">th_range</span><span class="p">])</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">'low'</span><span class="p">,</span> <span class="s1">'high'</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">threshold</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.anomaly_utilities.xfade">

<code class="highlight language-python"><span class="n">xfade</span><span class="p">(</span><span class="n">xfor</span><span class="p">,</span> <span class="n">xbac</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>xfade ("cross-fade") blends two data sets of matching length with a ramp function (weighted average).</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>xfor</code></td>
<td><code></code></td>
<td>
<p>forecasted data to be more weighted at the front</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>xbac</code></td>
<td><code></code></td>
<td>
<p>backcasted data to be more weighted at the back</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td>
<p>the blended data</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/anomaly_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">xfade</span><span class="p">(</span><span class="n">xfor</span><span class="p">,</span> <span class="n">xbac</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    xfade ("cross-fade") blends two data sets of matching length with a ramp function (weighted average).</span>
<span class="sd">    Arguments:</span>
<span class="sd">        xfor: forecasted data to be more weighted at the front</span>
<span class="sd">        xbac: backcasted data to be more weighted at the back</span>
<span class="sd">    Returns:</span>
<span class="sd">        x: the blended data</span>
<span class="sd">    """</span>
    <span class="c1"># if arrays are not matching in length</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xfor</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xbac</span><span class="p">)):</span>
        <span class="c1"># send error message</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"ERROR in xfade() call: mismatched array lengths!"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># initialize a weighting function</span>
        <span class="n">fader</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop over the length of data</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xfor</span><span class="p">)):</span>
            <span class="c1"># calculate the weights at each index</span>
            <span class="n">fader</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xfor</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># fader should be a ramp with positive slope between 0.0 and 1.0</span>
        <span class="c1"># use this to fade the back data</span>
        <span class="n">xbac_faded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">xbac</span><span class="p">,</span> <span class="n">fader</span><span class="p">)</span>

        <span class="c1"># now flip the ramp to negative slope and fade the front data</span>
        <span class="n">fader</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">fader</span><span class="p">)</span>
        <span class="n">xfor_faded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">xfor</span><span class="p">,</span> <span class="n">fader</span><span class="p">)</span>

        <span class="c1"># add the results</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xfor_faded</span> <span class="o">+</span> <span class="n">xbac_faded</span>

    <span class="k">return</span> <span class="n">x</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<h2 id="model-development-and-training-functions-module-modeling_utilities">Model Development and Training Functions (module: modeling_utilities)</h2>
<div class="doc doc-object doc-module">
<h2 class="hidden-toc" id="PyHydroQC.modeling_utilities" style="visibility: hidden; position: absolute;">
        </h2>
<div class="doc doc-contents first">
<div class="doc doc-children">
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.build_arima_model">

<code class="highlight language-python"><span class="n">build_arima_model</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>build_arima_model constructs and trains an ARIMA model.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data</code></td>
<td><code></code></td>
<td>
<p>series or data frame of time series inputs.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>p</code></td>
<td><code></code></td>
<td>
<p>ARIMA hyperparameter that can be determined by manual assessment or by automated means.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>d</code></td>
<td><code></code></td>
<td>
<p>ARIMA hyperparameter that can be determined by manual assessment or by automated means.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>q</code></td>
<td><code></code></td>
<td>
<p>ARIMA hyperparameter that can be determined by manual assessment or by automated means.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>summary</code></td>
<td><code></code></td>
<td>
<p>indicates if the model summary should be printed.</p>
</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>suppress_warnings</code></td>
<td><code></code></td>
<td>
<p>indicates whether warnings associated with ARIMA model development and fitting should be suppressed.</p>
</td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model_fit</code></td>
<td>
<p>SARIMAX model object.
residuals: series of model errors.
predictions: model predictions determine as the in sample, one step ahead model forecasted values.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">build_arima_model</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    build_arima_model constructs and trains an ARIMA model.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        data: series or data frame of time series inputs.</span>
<span class="sd">        p: ARIMA hyperparameter that can be determined by manual assessment or by automated means.</span>
<span class="sd">        d: ARIMA hyperparameter that can be determined by manual assessment or by automated means.</span>
<span class="sd">        q: ARIMA hyperparameter that can be determined by manual assessment or by automated means.</span>
<span class="sd">        summary: indicates if the model summary should be printed.</span>
<span class="sd">        suppress_warnings: indicates whether warnings associated with ARIMA model development and fitting should be suppressed.</span>
<span class="sd">    Returns:</span>
<span class="sd">        model_fit: SARIMAX model object.</span>
<span class="sd">        residuals: series of model errors.</span>
<span class="sd">        predictions: model predictions determine as the in sample, one step ahead model forecasted values.</span>
<span class="sd">    """</span>

    <span class="k">if</span> <span class="n">suppress_warnings</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">'A date index has been provided, but it has no associated frequency information and so will be ignored when e.g. forecasting'</span><span class="p">)</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">tsa</span><span class="o">.</span><span class="n">SARIMAX</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">suppress_warnings</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">'Non-stationary starting autoregressive parameters'</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">'Non-invertible starting MA parameters found.'</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">'ConvergenceWarning: Maximum Likelihood optimization failed to converge.'</span><span class="p">)</span>

    <span class="n">model_fit</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">warn_convergence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">suppress_warnings</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">'default'</span><span class="p">)</span>

    <span class="n">residuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">model_fit</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>
    <span class="n">predict</span> <span class="o">=</span> <span class="n">model_fit</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">()</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">predict</span><span class="o">.</span><span class="n">predicted_mean</span><span class="p">)</span>
    <span class="n">residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">predictions</span><span class="o">.</span><span class="n">predicted_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># output summary</span>
    <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n\n</span><span class="s1">'</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">model_fit</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n\n</span><span class="s1">residuals description:'</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">residuals</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">model_fit</span><span class="p">,</span> <span class="n">residuals</span><span class="p">,</span> <span class="n">predictions</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.create_bidir_model">

<code class="highlight language-python"><span class="n">create_bidir_model</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">,</span> <span class="n">num_features</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">input_loss</span><span class="o">=</span><span class="s1">'mae'</span><span class="p">,</span> <span class="n">input_optimizer</span><span class="o">=</span><span class="s1">'adam'</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>Uses sequential model class from keras. Adds bidirectional layer. Adds LSTM vanilla layer.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>time_steps</code></td>
<td><code></code></td>
<td>
<p>number of steps to consider for each point.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>num_features</code></td>
<td><code></code></td>
<td>
<p>number of variables being considered</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>cells</code></td>
<td><code></code></td>
<td>
<p>number of cells or nodes to be used to construct the model.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>dropout</code></td>
<td><code></code></td>
<td>
<p>ratio of cells to ignore for model training.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>input_loss</code></td>
<td><code></code></td>
<td>
<p>metric to be minimized for training. Default is mean average error ('mae').</p>
</td>
<td><code>'mae'</code></td>
</tr>
<tr>
<td><code>input_optimizer</code></td>
<td><code></code></td>
<td>
<p>algorithm for training model. Default is 'adam'.</p>
</td>
<td><code>'adam'</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model</code></td>
<td>
<p>keras model structure</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">create_bidir_model</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">,</span> <span class="n">num_features</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">input_loss</span><span class="o">=</span><span class="s1">'mae'</span><span class="p">,</span> <span class="n">input_optimizer</span><span class="o">=</span><span class="s1">'adam'</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Uses sequential model class from keras. Adds bidirectional layer. Adds LSTM vanilla layer.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        time_steps: number of steps to consider for each point.</span>
<span class="sd">        num_features: number of variables being considered</span>
<span class="sd">        cells: number of cells or nodes to be used to construct the model.</span>
<span class="sd">        dropout: ratio of cells to ignore for model training.</span>
<span class="sd">        input_loss: metric to be minimized for training. Default is mean average error ('mae').</span>
<span class="sd">        input_optimizer: algorithm for training model. Default is 'adam'.</span>
<span class="sd">    Returns:</span>
<span class="sd">        model: keras model structure</span>
<span class="sd">    """</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
    <span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Bidirectional</span><span class="p">(</span><span class="n">LSTM</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="n">dropout</span><span class="p">),</span> <span class="n">input_shape</span><span class="o">=</span><span class="p">(</span><span class="n">time_steps</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_features</span><span class="p">)))</span>
    <span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="n">num_features</span><span class="p">))</span>
    <span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="n">input_loss</span><span class="p">,</span> <span class="n">optimizer</span><span class="o">=</span><span class="n">input_optimizer</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">model</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.create_bidir_sequenced_dataset">

<code class="highlight language-python"><span class="n">create_bidir_sequenced_dataset</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">time_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>create_bidir_sequenced_dataset reshapes data to temporalize it into (samples, timestamps, features). Uses data before and after the point of interest (bidirectional).</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X</code></td>
<td><code></code></td>
<td>
<p>series of data to be reshaped.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>time_steps</code></td>
<td><code></code></td>
<td>
<p>number of past time steps to consider for each sample/row.</p>
</td>
<td><code>10</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Xs</code></td>
<td>
<p>array of data reshaped for input into an LSTM model.
ys: array of data outputs corresponding to each Xs input.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">create_bidir_sequenced_dataset</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">time_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    create_bidir_sequenced_dataset reshapes data to temporalize it into (samples, timestamps, features). Uses data before and after the point of interest (bidirectional).</span>
<span class="sd">    Arguments:</span>
<span class="sd">        X: series of data to be reshaped.</span>
<span class="sd">        time_steps: number of past time steps to consider for each sample/row.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Xs: array of data reshaped for input into an LSTM model.</span>
<span class="sd">        ys: array of data outputs corresponding to each Xs input.</span>
<span class="sd">    """</span>
    <span class="n">Xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>  <span class="c1"># start empty list</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">time_steps</span><span class="p">):</span>  <span class="c1"># loop within range of data frame minus the time steps</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="n">time_steps</span><span class="p">):</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):(</span><span class="n">i</span> <span class="o">+</span> <span class="n">time_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]])</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># data from i backward and forward the specified number of time steps</span>
        <span class="n">Xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Xs</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>  <span class="c1"># convert lists into numpy arrays and return</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.create_bidir_training_dataset">

<code class="highlight language-python"><span class="n">create_bidir_training_dataset</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">anomalies</span><span class="p">,</span> <span class="n">training_samples</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">time_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>create_bidir_training_dataset creates a training dataset based on random selection of a specified number of points within the dataset. Uses data before and after the point of interest (bidirectional).
Reshapes data to temporalize it into (samples, timestamps, features). Ensures that no data that has been corrected as part of preprocessing will be used for training the model.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X</code></td>
<td><code></code></td>
<td>
<p>data to be reshaped.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>anomalies</code></td>
<td><code></code></td>
<td>
<p>series of booleans where True (1) = anomalous data point corresponding to the results of preprocessing.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>training_samples</code></td>
<td><code></code></td>
<td>
<p>number of observations used for training.</p>
</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>time_steps</code></td>
<td><code></code></td>
<td>
<p>number of past time steps to consider for each sample/row.</p>
</td>
<td><code>10</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Xs</code></td>
<td>
<p>array of data reshaped for input into an LSTM model.
ys: array of data outputs corresponding to each Xs input.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">create_bidir_training_dataset</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">anomalies</span><span class="p">,</span> <span class="n">training_samples</span><span class="o">=</span><span class="s2">""</span><span class="p">,</span> <span class="n">time_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    create_bidir_training_dataset creates a training dataset based on random selection of a specified number of points within the dataset. Uses data before and after the point of interest (bidirectional).</span>
<span class="sd">    Reshapes data to temporalize it into (samples, timestamps, features). Ensures that no data that has been corrected as part of preprocessing will be used for training the model.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        X: data to be reshaped.</span>
<span class="sd">        anomalies: series of booleans where True (1) = anomalous data point corresponding to the results of preprocessing.</span>
<span class="sd">        training_samples: number of observations used for training.</span>
<span class="sd">        time_steps: number of past time steps to consider for each sample/row.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Xs: array of data reshaped for input into an LSTM model.</span>
<span class="sd">        ys: array of data outputs corresponding to each Xs input.</span>
<span class="sd">    """</span>
    <span class="n">Xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>  <span class="c1"># start empty list</span>
    <span class="k">if</span> <span class="n">training_samples</span> <span class="o">==</span> <span class="s2">""</span><span class="p">:</span>
        <span class="n">training_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.10</span><span class="p">)</span>

    <span class="c1"># create sample sequences from a randomized subset of the data series for training</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">time_steps</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">time_steps</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">training_samples</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">anomalies</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">time_steps</span><span class="p">):(</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">time_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">time_steps</span><span class="p">):</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):(</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">time_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]])</span><span class="o">.</span><span class="n">values</span>
            <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">Xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Xs</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>  <span class="c1"># convert lists into numpy arrays and return</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.create_scaler">

<code class="highlight language-python"><span class="n">create_scaler</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>create_scaler creates a scaler object based on input data that removes mean and scales to unit vectors.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data</code></td>
<td><code></code></td>
<td>
<p>a series of values to be scaled.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>scaler</code></td>
<td>
<p>a StandardScaler fit to the input data</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">create_scaler</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    create_scaler creates a scaler object based on input data that removes mean and scales to unit vectors.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        data: a series of values to be scaled.</span>
<span class="sd">    Returns:</span>
<span class="sd">        scaler: a StandardScaler fit to the input data</span>
<span class="sd">    """</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">scaler</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.create_sequenced_dataset">

<code class="highlight language-python"><span class="n">create_sequenced_dataset</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">time_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>create_sequenced_dataset reshapes data to temporalize it into (samples, timestamps, features).</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X</code></td>
<td><code></code></td>
<td>
<p>series of data to be reshaped.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>time_steps</code></td>
<td><code></code></td>
<td>
<p>number of past time steps to consider for each sample/row.</p>
</td>
<td><code>10</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Xs</code></td>
<td>
<p>array of data reshaped for input into an LSTM model.
ys: array of data outputs corresponding to each Xs input.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">create_sequenced_dataset</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">time_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    create_sequenced_dataset reshapes data to temporalize it into (samples, timestamps, features).</span>
<span class="sd">    Arguments:</span>
<span class="sd">        X: series of data to be reshaped.</span>
<span class="sd">        time_steps: number of past time steps to consider for each sample/row.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Xs: array of data reshaped for input into an LSTM model.</span>
<span class="sd">        ys: array of data outputs corresponding to each Xs input.</span>
<span class="sd">    """</span>
    <span class="n">Xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>  <span class="c1"># start empty list</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">time_steps</span><span class="p">):</span>  <span class="c1"># loop within range of data frame minus the time steps</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="n">time_steps</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># data from i to end of the time step</span>
        <span class="n">Xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">time_steps</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Xs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>  <span class="c1"># convert lists into numpy arrays and return</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.create_training_dataset">

<code class="highlight language-python"><span class="n">create_training_dataset</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">anomalies</span><span class="p">,</span> <span class="n">training_samples</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">time_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>create_training_dataset creates a training dataset based on random selection of a specified number of points within the dataset.
Reshapes data to temporalize it into (samples, timestamps, features). Ensures that no data that has been corrected as part of preprocessing will be used for training the model.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X</code></td>
<td><code></code></td>
<td>
<p>series of data to be reshaped.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>anomalies</code></td>
<td><code></code></td>
<td>
<p>series of booleans where True (1) = anomalous data point corresponding to the results of preprocessing.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>training_samples</code></td>
<td><code></code></td>
<td>
<p>number of observations used for training.</p>
</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>time_steps</code></td>
<td><code></code></td>
<td>
<p>number of past time steps to consider for each sample/row.</p>
</td>
<td><code>10</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Xs</code></td>
<td>
<p>array of data reshaped for input into an LSTM model.
ys: array of data output corresponding to each Xs input.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">create_training_dataset</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">anomalies</span><span class="p">,</span> <span class="n">training_samples</span><span class="o">=</span><span class="s2">""</span><span class="p">,</span> <span class="n">time_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    create_training_dataset creates a training dataset based on random selection of a specified number of points within the dataset.</span>
<span class="sd">    Reshapes data to temporalize it into (samples, timestamps, features). Ensures that no data that has been corrected as part of preprocessing will be used for training the model.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        X: series of data to be reshaped.</span>
<span class="sd">        anomalies: series of booleans where True (1) = anomalous data point corresponding to the results of preprocessing.</span>
<span class="sd">        training_samples: number of observations used for training.</span>
<span class="sd">        time_steps: number of past time steps to consider for each sample/row.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Xs: array of data reshaped for input into an LSTM model.</span>
<span class="sd">        ys: array of data output corresponding to each Xs input.</span>
<span class="sd">    """</span>
    <span class="n">Xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>  <span class="c1"># start empty list</span>
    <span class="k">if</span> <span class="n">training_samples</span> <span class="o">==</span> <span class="s2">""</span><span class="p">:</span>
        <span class="n">training_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.10</span><span class="p">)</span>

    <span class="c1"># create sample sequences from a randomized subset of the data series for training</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">time_steps</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">time_steps</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">training_samples</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">anomalies</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]:(</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">time_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]:(</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">time_steps</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">time_steps</span><span class="p">])</span>
            <span class="n">Xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Xs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>  <span class="c1"># convert lists into numpy arrays and return</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.create_vanilla_model">

<code class="highlight language-python"><span class="n">create_vanilla_model</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">,</span> <span class="n">num_features</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">input_loss</span><span class="o">=</span><span class="s1">'mae'</span><span class="p">,</span> <span class="n">input_optimizer</span><span class="o">=</span><span class="s1">'adam'</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>Uses sequential model class from keras. Adds LSTM vanilla layer.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>time_steps</code></td>
<td><code></code></td>
<td>
<p>number of steps to consider for each point.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>num_features</code></td>
<td><code></code></td>
<td>
<p>number of variables being considered</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>cells</code></td>
<td><code></code></td>
<td>
<p>number of cells or nodes to be used to construct the model.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>dropout</code></td>
<td><code></code></td>
<td>
<p>ratio of cells to ignore for model training.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>input_loss</code></td>
<td><code></code></td>
<td>
<p>metric to be minimized for training. Default is mean average error ('mae').</p>
</td>
<td><code>'mae'</code></td>
</tr>
<tr>
<td><code>input_optimizer</code></td>
<td><code></code></td>
<td>
<p>algorithm for training model. Default is 'adam'.</p>
</td>
<td><code>'adam'</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model</code></td>
<td>
<p>keras model structure</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">create_vanilla_model</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">,</span> <span class="n">num_features</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">input_loss</span><span class="o">=</span><span class="s1">'mae'</span><span class="p">,</span> <span class="n">input_optimizer</span><span class="o">=</span><span class="s1">'adam'</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Uses sequential model class from keras. Adds LSTM vanilla layer.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        time_steps: number of steps to consider for each point.</span>
<span class="sd">        num_features: number of variables being considered</span>
<span class="sd">        cells: number of cells or nodes to be used to construct the model.</span>
<span class="sd">        dropout: ratio of cells to ignore for model training.</span>
<span class="sd">        input_loss: metric to be minimized for training. Default is mean average error ('mae').</span>
<span class="sd">        input_optimizer: algorithm for training model. Default is 'adam'.</span>
<span class="sd">    Returns:</span>
<span class="sd">        model: keras model structure</span>
<span class="sd">    """</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
    <span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">LSTM</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">input_shape</span><span class="o">=</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="n">num_features</span><span class="p">),</span> <span class="n">dropout</span><span class="o">=</span><span class="n">dropout</span><span class="p">)),</span>  <span class="c1"># one LSTM layer with dropout regularization</span>
    <span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="n">num_features</span><span class="p">))</span>
    <span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="n">input_loss</span><span class="p">,</span> <span class="n">optimizer</span><span class="o">=</span><span class="n">input_optimizer</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">model</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.LSTM_multivar">

<code class="highlight language-python"><span class="n">LSTM_multivar</span><span class="p">(</span><span class="n">df_observed</span><span class="p">,</span> <span class="n">df_anomaly</span><span class="p">,</span> <span class="n">df_raw</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>LSTM_multivar builds, trains, and evaluates a vanilla LSTM model for multivariate data.</p>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">LSTM_multivar</span><span class="p">(</span><span class="n">df_observed</span><span class="p">,</span> <span class="n">df_anomaly</span><span class="p">,</span> <span class="n">df_raw</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    LSTM_multivar builds, trains, and evaluates a vanilla LSTM model for multivariate data.</span>
<span class="sd">    """</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">create_scaler</span><span class="p">(</span><span class="n">df_observed</span><span class="p">)</span>
    <span class="n">df_scaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df_observed</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">df_observed</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">df_observed</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">create_training_dataset</span><span class="p">(</span><span class="n">df_scaled</span><span class="p">,</span> <span class="n">df_anomaly</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'samples'</span><span class="p">],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">])</span>
    <span class="n">num_features</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'X_train shape: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'y_train shape: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Number of features: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_features</span><span class="p">))</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">create_vanilla_model</span><span class="p">(</span><span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'cells'</span><span class="p">],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">],</span> <span class="n">num_features</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'dropout'</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">history</span> <span class="o">=</span> <span class="n">train_model</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'patience'</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="n">df_raw_scaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df_raw</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">df_raw</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">df_raw</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">create_sequenced_dataset</span><span class="p">(</span><span class="n">df_raw_scaled</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">])</span>

    <span class="n">train_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
    <span class="n">test_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
    <span class="n">model_eval</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

    <span class="n">train_predictions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">train_pred</span><span class="p">))</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">test_pred</span><span class="p">))</span>
    <span class="n">y_train_unscaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_train</span><span class="p">))</span>
    <span class="n">y_test_unscaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_test</span><span class="p">))</span>

    <span class="n">train_residuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">train_predictions</span> <span class="o">-</span> <span class="n">y_train_unscaled</span><span class="p">))</span>
    <span class="n">test_residuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">predictions</span> <span class="o">-</span> <span class="n">y_test_unscaled</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">model_save</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">'originalsavedoutput/models/LSTM_multivar_'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">LSTM_multivar</span> <span class="o">=</span> <span class="n">LSTMModelContainer</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">model_output</span><span class="p">:</span>
        <span class="n">LSTM_multivar</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="n">LSTM_multivar</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span>
    <span class="n">LSTM_multivar</span><span class="o">.</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">X_train</span>
    <span class="n">LSTM_multivar</span><span class="o">.</span><span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span>
    <span class="n">LSTM_multivar</span><span class="o">.</span><span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span>
    <span class="n">LSTM_multivar</span><span class="o">.</span><span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span>
    <span class="n">LSTM_multivar</span><span class="o">.</span><span class="n">model_eval</span> <span class="o">=</span> <span class="n">model_eval</span>
    <span class="n">LSTM_multivar</span><span class="o">.</span><span class="n">predictions</span> <span class="o">=</span> <span class="n">predictions</span>
    <span class="n">LSTM_multivar</span><span class="o">.</span><span class="n">train_residuals</span> <span class="o">=</span> <span class="n">train_residuals</span>
    <span class="n">LSTM_multivar</span><span class="o">.</span><span class="n">test_residuals</span> <span class="o">=</span> <span class="n">test_residuals</span>

    <span class="k">return</span> <span class="n">LSTM_multivar</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.LSTM_multivar_bidir">

<code class="highlight language-python"><span class="n">LSTM_multivar_bidir</span><span class="p">(</span><span class="n">df_observed</span><span class="p">,</span> <span class="n">df_anomaly</span><span class="p">,</span> <span class="n">df_raw</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>LSTM_multivar_bidir builds, trains, and evaluates a bidirectional LSTM model for multivariate data.</p>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">LSTM_multivar_bidir</span><span class="p">(</span><span class="n">df_observed</span><span class="p">,</span> <span class="n">df_anomaly</span><span class="p">,</span> <span class="n">df_raw</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    LSTM_multivar_bidir builds, trains, and evaluates a bidirectional LSTM model for multivariate data.</span>
<span class="sd">    """</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">create_scaler</span><span class="p">(</span><span class="n">df_observed</span><span class="p">)</span>
    <span class="n">df_scaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df_observed</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">df_observed</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">df_observed</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">create_bidir_training_dataset</span><span class="p">(</span><span class="n">df_scaled</span><span class="p">,</span> <span class="n">df_anomaly</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'samples'</span><span class="p">],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">])</span>
    <span class="n">num_features</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'X_train shape: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'y_train shape: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Number of features: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_features</span><span class="p">))</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">create_bidir_model</span><span class="p">(</span><span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'cells'</span><span class="p">],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">],</span> <span class="n">num_features</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'dropout'</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">history</span> <span class="o">=</span> <span class="n">train_model</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'patience'</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="n">df_raw_scaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df_raw</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">df_raw</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">df_raw</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">create_bidir_sequenced_dataset</span><span class="p">(</span><span class="n">df_raw_scaled</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">])</span>

    <span class="n">train_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
    <span class="n">test_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
    <span class="n">model_eval</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

    <span class="n">train_predictions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">train_pred</span><span class="p">))</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">test_pred</span><span class="p">))</span>
    <span class="n">y_train_unscaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_train</span><span class="p">))</span>
    <span class="n">y_test_unscaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_test</span><span class="p">))</span>

    <span class="n">train_residuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">train_predictions</span> <span class="o">-</span> <span class="n">y_train_unscaled</span><span class="p">))</span>
    <span class="n">test_residuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">predictions</span> <span class="o">-</span> <span class="n">y_test_unscaled</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">model_save</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">'originalsavedoutput/models/LSTM_multiivar_bidir_'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">LSTM_multivar_bidir</span> <span class="o">=</span> <span class="n">LSTMModelContainer</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">model_output</span><span class="p">:</span>
        <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span>
    <span class="n">LSTM_multivar_bidir</span><span class="o">.</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">X_train</span>
    <span class="n">LSTM_multivar_bidir</span><span class="o">.</span><span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span>
    <span class="n">LSTM_multivar_bidir</span><span class="o">.</span><span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span>
    <span class="n">LSTM_multivar_bidir</span><span class="o">.</span><span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span>
    <span class="n">LSTM_multivar_bidir</span><span class="o">.</span><span class="n">model_eval</span> <span class="o">=</span> <span class="n">model_eval</span>
    <span class="n">LSTM_multivar_bidir</span><span class="o">.</span><span class="n">predictions</span> <span class="o">=</span> <span class="n">predictions</span>
    <span class="n">LSTM_multivar_bidir</span><span class="o">.</span><span class="n">train_residuals</span> <span class="o">=</span> <span class="n">train_residuals</span>
    <span class="n">LSTM_multivar_bidir</span><span class="o">.</span><span class="n">test_residuals</span> <span class="o">=</span> <span class="n">test_residuals</span>

    <span class="k">return</span> <span class="n">LSTM_multivar_bidir</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.LSTM_univar">

<code class="highlight language-python"><span class="n">LSTM_univar</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>LSTM_univar builds, trains, and evaluates a vanilla LSTM model for univariate data.</p>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">LSTM_univar</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    LSTM_univar builds, trains, and evaluates a vanilla LSTM model for univariate data.</span>
<span class="sd">    """</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">create_scaler</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">'observed'</span><span class="p">]])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'obs_scaled'</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">'observed'</span><span class="p">]])</span>

    <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">create_training_dataset</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">'obs_scaled'</span><span class="p">]],</span> <span class="n">df</span><span class="p">[[</span><span class="s1">'anomaly'</span><span class="p">]],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'samples'</span><span class="p">],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">])</span>
    <span class="n">num_features</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'X_train shape: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'y_train shape: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Number of features: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_features</span><span class="p">))</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">create_vanilla_model</span><span class="p">(</span><span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'cells'</span><span class="p">],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">],</span> <span class="n">num_features</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'dropout'</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">history</span> <span class="o">=</span> <span class="n">train_model</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'patience'</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">'raw_scaled'</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">'raw'</span><span class="p">]])</span>
    <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">create_sequenced_dataset</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">'raw_scaled'</span><span class="p">]],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">])</span>

    <span class="n">train_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
    <span class="n">test_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
    <span class="n">model_eval</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

    <span class="n">train_predictions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">train_pred</span><span class="p">))</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">test_pred</span><span class="p">))</span>
    <span class="n">y_train_unscaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_train</span><span class="p">))</span>
    <span class="n">y_test_unscaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_test</span><span class="p">))</span>

    <span class="n">train_residuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">train_predictions</span> <span class="o">-</span> <span class="n">y_train_unscaled</span><span class="p">))</span>
    <span class="n">test_residuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">predictions</span> <span class="o">-</span> <span class="n">y_test_unscaled</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">model_save</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">'originalsavedoutput/models/LSTM_univar_'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">LSTM_univar</span> <span class="o">=</span> <span class="n">LSTMModelContainer</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">model_output</span><span class="p">:</span>
        <span class="n">LSTM_univar</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="n">LSTM_univar</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span>
    <span class="n">LSTM_univar</span><span class="o">.</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">X_train</span>
    <span class="n">LSTM_univar</span><span class="o">.</span><span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span>
    <span class="n">LSTM_univar</span><span class="o">.</span><span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span>
    <span class="n">LSTM_univar</span><span class="o">.</span><span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span>
    <span class="n">LSTM_univar</span><span class="o">.</span><span class="n">model_eval</span> <span class="o">=</span> <span class="n">model_eval</span>
    <span class="n">LSTM_univar</span><span class="o">.</span><span class="n">predictions</span> <span class="o">=</span> <span class="n">predictions</span>
    <span class="n">LSTM_univar</span><span class="o">.</span><span class="n">train_residuals</span> <span class="o">=</span> <span class="n">train_residuals</span>
    <span class="n">LSTM_univar</span><span class="o">.</span><span class="n">test_residuals</span> <span class="o">=</span> <span class="n">test_residuals</span>

    <span class="k">return</span> <span class="n">LSTM_univar</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.LSTM_univar_bidir">

<code class="highlight language-python"><span class="n">LSTM_univar_bidir</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>LSTM_univar_bidir builds, trains, and evaluates a bidirectional LSTM model for univariate data.</p>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">LSTM_univar_bidir</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    LSTM_univar_bidir builds, trains, and evaluates a bidirectional LSTM model for univariate data.</span>
<span class="sd">    """</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">create_scaler</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">'observed'</span><span class="p">]])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'obs_scaled'</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">'observed'</span><span class="p">]])</span>

    <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">create_bidir_training_dataset</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">'obs_scaled'</span><span class="p">]],</span> <span class="n">df</span><span class="p">[[</span><span class="s1">'anomaly'</span><span class="p">]],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'samples'</span><span class="p">],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">])</span>

    <span class="n">num_features</span> <span class="o">=</span> <span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'X_train shape: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'y_train shape: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y_train</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Number of features: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_features</span><span class="p">))</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">create_bidir_model</span><span class="p">(</span><span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'cells'</span><span class="p">],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">],</span> <span class="n">num_features</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'dropout'</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">summary</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">history</span> <span class="o">=</span> <span class="n">train_model</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'patience'</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">'raw_scaled'</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">'raw'</span><span class="p">]])</span>
    <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">create_bidir_sequenced_dataset</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">'raw_scaled'</span><span class="p">]],</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">])</span>

    <span class="n">train_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
    <span class="n">test_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
    <span class="n">model_eval</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

    <span class="n">train_predictions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">train_pred</span><span class="p">))</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">test_pred</span><span class="p">))</span>
    <span class="n">y_train_unscaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_train</span><span class="p">))</span>
    <span class="n">y_test_unscaled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_test</span><span class="p">))</span>

    <span class="n">train_residuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">train_predictions</span> <span class="o">-</span> <span class="n">y_train_unscaled</span><span class="p">))</span>
    <span class="n">test_residuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">predictions</span> <span class="o">-</span> <span class="n">y_test_unscaled</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">model_save</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">'originalsavedoutput/models/LSTM_univar_bidir_'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">LSTM_univar_bidir</span> <span class="o">=</span> <span class="n">LSTMModelContainer</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">model_output</span><span class="p">:</span>
        <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span>
    <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">X_train</span>
    <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span>
    <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test</span>
    <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span>
    <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">model_eval</span> <span class="o">=</span> <span class="n">model_eval</span>
    <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">predictions</span> <span class="o">=</span> <span class="n">predictions</span>
    <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">train_residuals</span> <span class="o">=</span> <span class="n">train_residuals</span>
    <span class="n">LSTM_univar_bidir</span><span class="o">.</span><span class="n">test_residuals</span> <span class="o">=</span> <span class="n">test_residuals</span>

    <span class="k">return</span> <span class="n">LSTM_univar_bidir</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.pdq">

<code class="highlight language-python"><span class="n">pdq</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>pdq is an automated function for finding the order (hyperparameters) of an ARIMA model.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data</code></td>
<td><code></code></td>
<td>
<p>series of observations</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pdq</code></td>
<td>
<p>list of (p,d,q) ARIMA hyperparameters</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">pdq</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    pdq is an automated function for finding the order (hyperparameters) of an ARIMA model.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        data: series of observations</span>
<span class="sd">    Returns:</span>
<span class="sd">        pdq: list of (p,d,q) ARIMA hyperparameters</span>
<span class="sd">    """</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">auto_arima</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">seasonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">error_action</span><span class="o">=</span><span class="s2">"ignore"</span><span class="p">)</span>
    <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">order</span>
    <span class="n">pdq</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">pdq</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.modeling_utilities.train_model">

<code class="highlight language-python"><span class="n">train_model</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">patience</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="s1">'val_loss'</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'min'</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">validation_split</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>train_model fits the model to training data. Early stopping ensures that too many epochs of training are not used.
Monitors the validation loss for improvements and stops training when improvement stops.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X_train</code></td>
<td><code></code></td>
<td>
<p>training input data (output of one of the create_training_data functions)</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>y_train</code></td>
<td><code></code></td>
<td>
<p>training output data (output of one of the create_training_data functions)</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>model</code></td>
<td><code></code></td>
<td>
<p>existing LSTM model structure (output of one of the create_model functions)</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>patience</code></td>
<td><code></code></td>
<td>
<p>how many epochs to wait for early stopping.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>epochs</code></td>
<td><code></code></td>
<td>
<p>how many training epochs to use.</p>
</td>
<td><code>100</code></td>
</tr>
<tr>
<td><code>verbose</code></td>
<td><code></code></td>
<td>
<p>what type of output to show. 0 is silent. 1 is progress bar. 2 is one line per epoch.</p>
</td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>batch_size</code></td>
<td><code></code></td>
<td>
<p>hyperparameter.</p>
</td>
<td><code>32</code></td>
</tr>
<tr>
<td><code>validation_split</code></td>
<td><code></code></td>
<td>
<p>indicates how much data to use for internal training.</p>
</td>
<td><code>0.1</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>history</code></td>
<td>
<p>keras model.fit object</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/modeling_utilities.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">train_model</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">patience</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="s1">'val_loss'</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'min'</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
                <span class="n">validation_split</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    train_model fits the model to training data. Early stopping ensures that too many epochs of training are not used.</span>
<span class="sd">    Monitors the validation loss for improvements and stops training when improvement stops.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        X_train: training input data (output of one of the create_training_data functions)</span>
<span class="sd">        y_train: training output data (output of one of the create_training_data functions)</span>
<span class="sd">        model: existing LSTM model structure (output of one of the create_model functions)</span>
<span class="sd">        patience: how many epochs to wait for early stopping.</span>
<span class="sd">        epochs: how many training epochs to use.</span>
<span class="sd">        verbose: what type of output to show. 0 is silent. 1 is progress bar. 2 is one line per epoch.</span>
<span class="sd">        batch_size: hyperparameter.</span>
<span class="sd">        validation_split: indicates how much data to use for internal training.</span>
<span class="sd">    Returns:</span>
<span class="sd">        history: keras model.fit object</span>
<span class="sd">    """</span>
    <span class="n">es</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">EarlyStopping</span><span class="p">(</span><span class="n">monitor</span><span class="o">=</span><span class="n">monitor</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="n">history</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
        <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span>
        <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>  <span class="c1"># just set to something high, early stopping will monitor.</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="c1"># how to give output. 0 is silent. 1 is progress bar. 2 is one line per epoch.</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>  <span class="c1"># this can be optimized later</span>
        <span class="n">validation_split</span><span class="o">=</span><span class="n">validation_split</span><span class="p">,</span>  <span class="c1"># use 10% of data for validation, use 90% for training.</span>
        <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">es</span><span class="p">],</span>  <span class="c1"># early stopping similar to earlier</span>
        <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># because order matters</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">history</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<h2 id="workflow-functions-for-model-based-anomaly-detection-model_workflow">Workflow Functions for Model Based Anomaly Detection (model_workflow)</h2>
<div class="doc doc-object doc-module">
<h2 class="hidden-toc" id="PyHydroQC.model_workflow" style="visibility: hidden; position: absolute;">
        </h2>
<div class="doc doc-contents first">
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h2 class="doc doc-heading" id="PyHydroQC.model_workflow.ModelType">

        <code>ModelType</code>



      </h2>
<div class="doc doc-contents ">
<div class="doc doc-children">













  </div>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.model_workflow.ARIMA_detect">

<code class="highlight language-python"><span class="n">ARIMA_detect</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">sensor</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">rules</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compare</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<details class="quote">
          <summary>Source code in <code>PyHydroQC/model_workflow.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">ARIMA_detect</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">sensor</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                 <span class="n">rules</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compare</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    """</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">Processing ARIMA detections.'</span><span class="p">)</span>
    <span class="c1"># RULES BASED DETECTION #</span>
    <span class="k">if</span> <span class="n">rules</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">range_check</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s1">'max_range'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'min_range'</span><span class="p">])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">persistence</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s1">'persist'</span><span class="p">])</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">group_size</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">sensor</span> <span class="o">+</span> <span class="s1">' rules based detection complete. Longest detected group = '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>

    <span class="c1"># MODEL CREATION #</span>
    <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'pdq'</span><span class="p">]</span>
    <span class="n">model_fit</span><span class="p">,</span> <span class="n">residuals</span><span class="p">,</span> <span class="n">predictions</span> <span class="o">=</span> <span class="n">modeling_utilities</span><span class="o">.</span><span class="n">build_arima_model</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'observed'</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sensor</span> <span class="o">+</span> <span class="s1">' ARIMA model complete.'</span><span class="p">)</span>

    <span class="c1"># DETERMINE THRESHOLD AND DETECT ANOMALIES #</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">set_dynamic_threshold</span><span class="p">(</span><span class="n">residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'window_sz'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'alpha'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'threshold_min'</span><span class="p">])</span>
    <span class="n">threshold</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">residuals</span><span class="o">.</span><span class="n">index</span>
    <span class="k">if</span> <span class="n">plots</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">plt_threshold</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">sensor</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Threshold determination complete.'</span><span class="p">)</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">detect_anomalies</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'observed'</span><span class="p">],</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">residuals</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># WIDEN AND NUMBER ANOMALOUS EVENTS #</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'detected_anomaly'</span><span class="p">]</span> <span class="o">=</span> <span class="n">detections</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'all_anomalies'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s1">'detected_anomaly or anomaly'</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">anomaly_events</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'all_anomalies'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'widen'</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">compare</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">anomaly_events</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'labeled_anomaly'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'widen'</span><span class="p">])</span>
        <span class="c1"># DETERMINE METRICS #</span>
        <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">compare_events</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s1">'widen'</span><span class="p">])</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">metrics</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="n">e_metrics</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">event_metrics</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="c1"># OUTPUT RESULTS #</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Model type: ARIMA'</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Sensor: '</span> <span class="o">+</span> <span class="n">sensor</span><span class="p">)</span>
        <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">print_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Event based calculations:'</span><span class="p">)</span>
        <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">print_metrics</span><span class="p">(</span><span class="n">e_metrics</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Model report complete</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>

    <span class="c1"># GENERATE PLOTS #</span>
    <span class="k">if</span> <span class="n">plots</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">plt_results</span><span class="p">(</span>
            <span class="n">raw</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">'raw'</span><span class="p">],</span>
            <span class="n">predictions</span><span class="o">=</span><span class="n">detections</span><span class="p">[</span><span class="s1">'prediction'</span><span class="p">],</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">],</span>
            <span class="n">detections</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">],</span>
            <span class="n">sensor</span><span class="o">=</span><span class="n">sensor</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="n">ARIMA_detect</span> <span class="o">=</span> <span class="n">ModelWorkflow</span><span class="p">()</span>
    <span class="n">ARIMA_detect</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span>
    <span class="n">ARIMA_detect</span><span class="o">.</span><span class="n">model_fit</span> <span class="o">=</span> <span class="n">model_fit</span>
    <span class="n">ARIMA_detect</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
    <span class="n">ARIMA_detect</span><span class="o">.</span><span class="n">detections</span> <span class="o">=</span> <span class="n">detections</span>
    <span class="k">if</span> <span class="n">compare</span><span class="p">:</span>
        <span class="n">ARIMA_detect</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">metrics</span>
        <span class="n">ARIMA_detect</span><span class="o">.</span><span class="n">e_metrics</span> <span class="o">=</span> <span class="n">e_metrics</span>

    <span class="k">return</span> <span class="n">ARIMA_detect</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.model_workflow.LSTM_detect_multivar">

<code class="highlight language-python"><span class="n">LSTM_detect_multivar</span><span class="p">(</span><span class="n">sensor_array</span><span class="p">,</span> <span class="n">sensors</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">model_type</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">rules</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compare</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<details class="quote">
          <summary>Source code in <code>PyHydroQC/model_workflow.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">LSTM_detect_multivar</span><span class="p">(</span><span class="n">sensor_array</span><span class="p">,</span> <span class="n">sensors</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">model_type</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span>
                <span class="n">rules</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compare</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    """</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">Processing LSTM multivariate '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">model_type</span><span class="p">)</span> <span class="o">+</span> <span class="s1">' detections.'</span><span class="p">)</span>
    <span class="c1"># RULES BASED DETECTION #</span>
    <span class="k">if</span> <span class="n">rules</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">snsr</span> <span class="ow">in</span> <span class="n">sensors</span><span class="p">:</span>
            <span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">r_c</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">range_check</span><span class="p">(</span><span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span><span class="o">.</span><span class="n">max_range</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span><span class="o">.</span><span class="n">min_range</span><span class="p">)</span>
            <span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">p_c</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">persistence</span><span class="p">(</span><span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span><span class="o">.</span><span class="n">persist</span><span class="p">)</span>
            <span class="n">size</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">group_size</span><span class="p">(</span><span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">])</span>
            <span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">snsr</span> <span class="o">+</span> <span class="s1">' maximum detected group length = '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">snsr</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Rules based detection complete.</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
    <span class="c1"># Create new data frames with raw and observed (after applying rules) and preliminary anomaly detections for selected sensors</span>
    <span class="n">df_raw</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">sensor_array</span><span class="p">[</span><span class="n">sensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">df_observed</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">sensor_array</span><span class="p">[</span><span class="n">sensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">df_anomaly</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">sensor_array</span><span class="p">[</span><span class="n">sensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">snsr</span> <span class="ow">in</span> <span class="n">sensors</span><span class="p">:</span>
        <span class="n">df_raw</span><span class="p">[</span><span class="n">snsr</span> <span class="o">+</span> <span class="s1">'_raw'</span><span class="p">]</span> <span class="o">=</span> <span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'raw'</span><span class="p">]</span>
        <span class="n">df_observed</span><span class="p">[</span><span class="n">snsr</span> <span class="o">+</span> <span class="s1">'_obs'</span><span class="p">]</span> <span class="o">=</span> <span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'observed'</span><span class="p">]</span>
        <span class="n">df_anomaly</span><span class="p">[</span><span class="n">snsr</span> <span class="o">+</span> <span class="s1">'_anom'</span><span class="p">]</span> <span class="o">=</span> <span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'anomaly'</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Raw data shape: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">df_raw</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Observed data shape: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">df_observed</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Initial anomalies data shape: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">df_anomaly</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># MODEL CREATION #</span>
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">VANILLA</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">modeling_utilities</span><span class="o">.</span><span class="n">LSTM_multivar</span><span class="p">(</span><span class="n">df_observed</span><span class="p">,</span> <span class="n">df_anomaly</span><span class="p">,</span> <span class="n">df_raw</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="p">,</span> <span class="n">model_save</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">BIDIRECTIONAL</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">modeling_utilities</span><span class="o">.</span><span class="n">LSTM_multivar_bidir</span><span class="p">(</span><span class="n">df_observed</span><span class="p">,</span> <span class="n">df_anomaly</span><span class="p">,</span> <span class="n">df_raw</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="p">,</span> <span class="n">model_save</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">'multivariate '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">model_type</span><span class="p">)</span> <span class="o">+</span> <span class="s1">' LSTM model complete.</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
    <span class="c1"># Plot Metrics and Evaluate the Model</span>
    <span class="k">if</span> <span class="n">plots</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">'loss'</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">'Training Loss'</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">'val_loss'</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">'Validation Loss'</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># DETERMINE THRESHOLD AND DETECT ANOMALIES #</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">]</span>
    <span class="n">residuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">test_residuals</span><span class="p">)</span>
    <span class="n">residuals</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">sensors</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">predictions</span><span class="p">)</span>
    <span class="n">predictions</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">sensors</span>
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">VANILLA</span><span class="p">:</span>
        <span class="n">residuals</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_observed</span><span class="p">[</span><span class="n">ts</span><span class="p">:]</span><span class="o">.</span><span class="n">index</span>
        <span class="n">predictions</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_observed</span><span class="p">[</span><span class="n">ts</span><span class="p">:]</span><span class="o">.</span><span class="n">index</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="n">df_observed</span><span class="p">[</span><span class="n">ts</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">BIDIRECTIONAL</span><span class="p">:</span>
        <span class="n">residuals</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_observed</span><span class="p">[</span><span class="n">ts</span><span class="p">:</span><span class="o">-</span><span class="n">ts</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
        <span class="n">predictions</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_observed</span><span class="p">[</span><span class="n">ts</span><span class="p">:</span><span class="o">-</span><span class="n">ts</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="n">df_observed</span><span class="p">[</span><span class="n">ts</span><span class="p">:</span><span class="o">-</span><span class="n">ts</span><span class="p">]</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">snsr</span> <span class="ow">in</span> <span class="n">sensors</span><span class="p">:</span>
        <span class="n">threshold</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">set_dynamic_threshold</span><span class="p">(</span>
            <span class="n">residuals</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'window_sz'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'alpha'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'threshold_min'</span><span class="p">])</span>
        <span class="n">threshold</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">residuals</span><span class="o">.</span><span class="n">index</span>
        <span class="n">detections</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">detect_anomalies</span><span class="p">(</span>
            <span class="n">observed</span><span class="p">[</span><span class="n">snsr</span><span class="o">+</span><span class="s1">'_obs'</span><span class="p">],</span> <span class="n">predictions</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">residuals</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">threshold</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plots</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">plt_threshold</span><span class="p">(</span><span class="n">residuals</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">threshold</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">sensors</span><span class="p">[</span><span class="n">snsr</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Threshold determination complete.'</span><span class="p">)</span>

    <span class="c1"># WIDEN AND NUMBER ANOMALOUS EVENTS #</span>
    <span class="n">all_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">snsr</span> <span class="ow">in</span> <span class="n">sensors</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">VANILLA</span><span class="p">:</span>
            <span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ts</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">BIDIRECTIONAL</span><span class="p">:</span>
            <span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ts</span><span class="p">:</span><span class="o">-</span><span class="n">ts</span><span class="p">]</span>
        <span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'detected_anomaly'</span><span class="p">]</span> <span class="o">=</span> <span class="n">detections</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'anomaly'</span><span class="p">]</span>
        <span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'all_anomalies'</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s1">'detected_anomaly or anomaly'</span><span class="p">)</span>
        <span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'detected_event'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">anomaly_events</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'all_anomalies'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'widen'</span><span class="p">])</span>

    <span class="c1"># COMPARE AND DETERMINE METRICS #</span>
    <span class="k">if</span> <span class="n">compare</span><span class="p">:</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">e_metrics</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">snsr</span> <span class="ow">in</span> <span class="n">sensors</span><span class="p">:</span>
            <span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'labeled_event'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">anomaly_events</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'labeled_anomaly'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'widen'</span><span class="p">])</span>
            <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">compare_events</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'widen'</span><span class="p">])</span>
            <span class="n">metrics</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">metrics</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">])</span>
            <span class="n">e_metrics</span><span class="p">[</span><span class="n">snsr</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">event_metrics</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">])</span>
        <span class="c1"># OUTPUT RESULTS #</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">Model type: LSTM multivariate '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">model_type</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'Sensor: '</span> <span class="o">+</span> <span class="n">snsr</span><span class="p">)</span>
            <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">print_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="n">snsr</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'Event based calculations:'</span><span class="p">)</span>
            <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">print_metrics</span><span class="p">(</span><span class="n">e_metrics</span><span class="p">[</span><span class="n">snsr</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Model report complete</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>

    <span class="c1"># GENERATE PLOTS #</span>
    <span class="k">if</span> <span class="n">plots</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">snsr</span> <span class="ow">in</span> <span class="n">sensors</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">plt_results</span><span class="p">(</span>
                <span class="n">raw</span><span class="o">=</span><span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'raw'</span><span class="p">],</span>
                <span class="n">predictions</span><span class="o">=</span><span class="n">detections</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'prediction'</span><span class="p">],</span>
                <span class="n">labels</span><span class="o">=</span><span class="n">sensor_array</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'labeled_event'</span><span class="p">],</span>
                <span class="n">detections</span><span class="o">=</span><span class="n">all_data</span><span class="p">[</span><span class="n">snsr</span><span class="p">][</span><span class="s1">'detected_event'</span><span class="p">],</span>
                <span class="n">sensor</span><span class="o">=</span><span class="n">snsr</span>
                <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="n">LSTM_detect_multivar</span> <span class="o">=</span> <span class="n">ModelWorkflow</span><span class="p">()</span>
    <span class="n">LSTM_detect_multivar</span><span class="o">.</span><span class="n">sensor_array</span> <span class="o">=</span> <span class="n">sensor_array</span>
    <span class="n">LSTM_detect_multivar</span><span class="o">.</span><span class="n">df_observed</span> <span class="o">=</span> <span class="n">df_observed</span>
    <span class="n">LSTM_detect_multivar</span><span class="o">.</span><span class="n">df_raw</span> <span class="o">=</span> <span class="n">df_raw</span>
    <span class="n">LSTM_detect_multivar</span><span class="o">.</span><span class="n">df_anomaly</span> <span class="o">=</span> <span class="n">df_anomaly</span>
    <span class="n">LSTM_detect_multivar</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
    <span class="n">LSTM_detect_multivar</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
    <span class="n">LSTM_detect_multivar</span><span class="o">.</span><span class="n">detections</span> <span class="o">=</span> <span class="n">detections</span>
    <span class="n">LSTM_detect_multivar</span><span class="o">.</span><span class="n">all_data</span> <span class="o">=</span> <span class="n">all_data</span>
    <span class="k">if</span> <span class="n">compare</span><span class="p">:</span>
        <span class="n">LSTM_detect_multivar</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">metrics</span>
        <span class="n">LSTM_detect_multivar</span><span class="o">.</span><span class="n">e_metrics</span> <span class="o">=</span> <span class="n">e_metrics</span>

    <span class="k">return</span> <span class="n">LSTM_detect_multivar</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.model_workflow.LSTM_detect_univar">

<code class="highlight language-python"><span class="n">LSTM_detect_univar</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">sensor</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">model_type</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">rules</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compare</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<details class="quote">
          <summary>Source code in <code>PyHydroQC/model_workflow.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">LSTM_detect_univar</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">sensor</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">model_type</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span>
                <span class="n">rules</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compare</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">model_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    """</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">Processing LSTM univariate '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">model_type</span><span class="p">)</span> <span class="o">+</span> <span class="s1">' detections.'</span><span class="p">)</span>
    <span class="c1"># RULES BASED DETECTION #</span>
    <span class="k">if</span> <span class="n">rules</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">range_check</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s1">'max_range'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'min_range'</span><span class="p">])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">persistence</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s1">'persist'</span><span class="p">])</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">group_size</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">rules_detect</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">sensor</span> <span class="o">+</span> <span class="s1">' rules based detection complete. Maximum detected group length = '</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>

    <span class="c1"># MODEL CREATION #</span>
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">VANILLA</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">modeling_utilities</span><span class="o">.</span><span class="n">LSTM_univar</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="p">,</span> <span class="n">model_save</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">BIDIRECTIONAL</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">modeling_utilities</span><span class="o">.</span><span class="n">LSTM_univar_bidir</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">LSTM_params</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model_output</span><span class="p">,</span> <span class="n">model_save</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sensor</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">model_type</span><span class="p">)</span> <span class="o">+</span> <span class="s1">' LSTM model complete.'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plots</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">'loss'</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">'Training Loss'</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">'val_loss'</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">'Validation Loss'</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># DETERMINE THRESHOLD AND DETECT ANOMALIES #</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">LSTM_params</span><span class="p">[</span><span class="s1">'time_steps'</span><span class="p">]</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">set_dynamic_threshold</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">test_residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'window_sz'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'alpha'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'threshold_min'</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">VANILLA</span><span class="p">:</span>
        <span class="n">threshold</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">ts</span><span class="p">:]</span><span class="o">.</span><span class="n">index</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">BIDIRECTIONAL</span><span class="p">:</span>
        <span class="n">threshold</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">ts</span><span class="p">:</span><span class="o">-</span><span class="n">ts</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
    <span class="n">residuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">test_residuals</span><span class="p">)</span>
    <span class="n">residuals</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">.</span><span class="n">index</span>
    <span class="k">if</span> <span class="n">plots</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">plt_threshold</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">sensor</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">VANILLA</span><span class="p">:</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">'observed'</span><span class="p">]][</span><span class="n">ts</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">BIDIRECTIONAL</span><span class="p">:</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">'observed'</span><span class="p">]][</span><span class="n">ts</span><span class="p">:</span><span class="o">-</span><span class="n">ts</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Threshold determination complete.'</span><span class="p">)</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">detect_anomalies</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">predictions</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">test_residuals</span><span class="p">,</span>
                                                    <span class="n">threshold</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># WIDEN AND NUMBER ANOMALOUS EVENTS #</span>
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">VANILLA</span><span class="p">:</span>
        <span class="n">df_anomalies</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ts</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">ModelType</span><span class="o">.</span><span class="n">BIDIRECTIONAL</span><span class="p">:</span>
        <span class="n">df_anomalies</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ts</span><span class="p">:</span><span class="o">-</span><span class="n">ts</span><span class="p">]</span>
    <span class="n">df_anomalies</span><span class="p">[</span><span class="s1">'detected_anomaly'</span><span class="p">]</span> <span class="o">=</span> <span class="n">detections</span><span class="p">[</span><span class="s1">'anomaly'</span><span class="p">]</span>
    <span class="n">df_anomalies</span><span class="p">[</span><span class="s1">'all_anomalies'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_anomalies</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s1">'detected_anomaly or anomaly'</span><span class="p">)</span>
    <span class="n">df_anomalies</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">anomaly_events</span><span class="p">(</span><span class="n">df_anomalies</span><span class="p">[</span><span class="s1">'all_anomalies'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'widen'</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">compare</span><span class="p">:</span>
        <span class="n">df_anomalies</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">anomaly_events</span><span class="p">(</span><span class="n">df_anomalies</span><span class="p">[</span><span class="s1">'labeled_anomaly'</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">'widen'</span><span class="p">])</span>
        <span class="c1"># DETERMINE METRICS #</span>
        <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">compare_events</span><span class="p">(</span><span class="n">df_anomalies</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s1">'widen'</span><span class="p">])</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">metrics</span><span class="p">(</span><span class="n">df_anomalies</span><span class="p">)</span>
        <span class="n">e_metrics</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">event_metrics</span><span class="p">(</span><span class="n">df_anomalies</span><span class="p">)</span>
        <span class="c1"># OUTPUT RESULTS #</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Model type: LSTM univariate '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">model_type</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Sensor: '</span> <span class="o">+</span> <span class="n">sensor</span><span class="p">)</span>
        <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">print_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Event based calculations:'</span><span class="p">)</span>
        <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">print_metrics</span><span class="p">(</span><span class="n">e_metrics</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Model report complete</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>

    <span class="c1"># GENERATE PLOTS #</span>
    <span class="k">if</span> <span class="n">plots</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">plt_results</span><span class="p">(</span>
            <span class="n">raw</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">'raw'</span><span class="p">],</span>
            <span class="n">predictions</span><span class="o">=</span><span class="n">detections</span><span class="p">[</span><span class="s1">'prediction'</span><span class="p">],</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">'labeled_event'</span><span class="p">],</span>
            <span class="n">detections</span><span class="o">=</span><span class="n">df_anomalies</span><span class="p">[</span><span class="s1">'detected_event'</span><span class="p">],</span>
            <span class="n">sensor</span><span class="o">=</span><span class="n">sensor</span>
            <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="n">LSTM_detect_univar</span> <span class="o">=</span> <span class="n">ModelWorkflow</span><span class="p">()</span>
    <span class="n">LSTM_detect_univar</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span>
    <span class="n">LSTM_detect_univar</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
    <span class="n">LSTM_detect_univar</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
    <span class="n">LSTM_detect_univar</span><span class="o">.</span><span class="n">detections</span> <span class="o">=</span> <span class="n">detections</span>
    <span class="n">LSTM_detect_univar</span><span class="o">.</span><span class="n">df_anomalies</span> <span class="o">=</span> <span class="n">df_anomalies</span>
    <span class="k">if</span> <span class="n">compare</span><span class="p">:</span>
        <span class="n">LSTM_detect_univar</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">metrics</span>
        <span class="n">LSTM_detect_univar</span><span class="o">.</span><span class="n">e_metrics</span> <span class="o">=</span> <span class="n">e_metrics</span>

    <span class="k">return</span> <span class="n">LSTM_detect_univar</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<h2 id="model-based-correction-functions-arima_correct">Model Based Correction Functions (ARIMA_correct)</h2>
<div class="doc doc-object doc-module">
<h2 class="hidden-toc" id="PyHydroQC.ARIMA_correct" style="visibility: hidden; position: absolute;">
        </h2>
<div class="doc doc-contents first">
<div class="doc doc-children">
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.ARIMA_correct.ARIMA_forecast">

<code class="highlight language-python"><span class="n">ARIMA_forecast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>ARIMA_forecast creates predictions of data where anomalies occur. Creates ARIMA model and outputs forecasts of specified length.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td><code></code></td>
<td>
<p>array of values from which to predict corrections. corresponds to non-anomalous data.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>l</code></td>
<td><code></code></td>
<td>
<p>number of predicted data points to be forecasted/corrected.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>suppress_warnings</code></td>
<td><code></code></td>
<td>
<p>indicates whether warnings associated with ARIMA model development and fitting should be suppressed.</p>
</td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>y</code></td>
<td>
<p>array of length l of the corrected values as predicted by the model</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/ARIMA_correct.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">ARIMA_forecast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    ARIMA_forecast creates predictions of data where anomalies occur. Creates ARIMA model and outputs forecasts of specified length.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        x: array of values from which to predict corrections. corresponds to non-anomalous data.</span>
<span class="sd">        l: number of predicted data points to be forecasted/corrected.</span>
<span class="sd">        suppress_warnings: indicates whether warnings associated with ARIMA model development and fitting should be suppressed.</span>
<span class="sd">    Returns:</span>
<span class="sd">        y: array of length l of the corrected values as predicted by the model</span>
<span class="sd">    """</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">auto_arima</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">error_action</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">suppress_warnings</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">'Non-stationary starting autoregressive parameters'</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">'Non-invertible starting MA parameters found.'</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">'ConvergenceWarning: Maximum Likelihood optimization failed to converge.'</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.ARIMA_correct.ARIMA_group">

<code class="highlight language-python"><span class="n">ARIMA_group</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">anomalies</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">min_group_len</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>ARIMA_group examines detected events and performs conditional widening (marks some valid points as anomalous) to ensure that widened event is sufficient for forecasting/backcasting.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with a column for detected events.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>anomalies</code></td>
<td><code></code></td>
<td>
<p>string of the column name for detected events.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>group</code></td>
<td><code></code></td>
<td>
<p>string of column name containing an ascending index for each group of valid or anomolous data points (output of the group_bools function).</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>min_group_len</code></td>
<td><code></code></td>
<td>
<p>the minimum group length.</p>
</td>
<td><code>20</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td>
<p>data frame with new columns: 'ARIMA_event' and 'ARIMA_group'</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/ARIMA_correct.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">ARIMA_group</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">anomalies</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">min_group_len</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    ARIMA_group examines detected events and performs conditional widening (marks some valid points as anomalous) to ensure that widened event is sufficient for forecasting/backcasting.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with a column for detected events.</span>
<span class="sd">        anomalies: string of the column name for detected events.</span>
<span class="sd">        group: string of column name containing an ascending index for each group of valid or anomolous data points (output of the group_bools function).</span>
<span class="sd">        min_group_len: the minimum group length.</span>
<span class="sd">    Returns:</span>
<span class="sd">        df: data frame with new columns: 'ARIMA_event' and 'ARIMA_group'</span>
<span class="sd">    """</span>
    <span class="n">ARIMA_group</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_event'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">anomalies</span><span class="p">]</span>
    <span class="n">new_gi</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># for each group</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">group</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="c1"># determine the length of this group</span>
        <span class="n">group_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">][</span><span class="n">group</span><span class="p">])</span>
        <span class="c1"># if this group is not an anomaly event and is too small to support an ARIMA model</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">][</span><span class="n">anomalies</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">group_len</span> <span class="o">&lt;</span> <span class="n">min_group_len</span><span class="p">)):</span>
            <span class="c1"># this group needs to be added to previous group</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'ARIMA_event'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">new_gi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">new_gi</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">ARIMA_group</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">group_len</span><span class="p">],</span> <span class="n">new_gi</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># this group does not need to be altered</span>
            <span class="n">ARIMA_group</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">group_len</span><span class="p">],</span> <span class="n">new_gi</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">new_gi</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">new_gi</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">group</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"WARNING: more than half of the anomaly events have been merged!"</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ARIMA_group</span>

    <span class="k">return</span> <span class="n">df</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="PyHydroQC.ARIMA_correct.generate_corrections">

<code class="highlight language-python"><span class="n">generate_corrections</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">observed</span><span class="p">,</span> <span class="n">anomalies</span><span class="p">,</span> <span class="n">model_limit</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">savecasts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


      </h2>
<div class="doc doc-contents ">
<p>generate_corrections passes through data with identified anomalies and determines corrections using ARIMA models.
Corrections are determined by combining both a forecast and a backcast in a weighted average that is informed by
non-anamolous data before and after anomalies. Corrections are generated for anomalies by order of the shortest to
longest and those corrected values from the shorter anomalies are used with non-anomalous values to generate
corrections for longer anomalies.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df</code></td>
<td><code></code></td>
<td>
<p>data frame with columns for observations and anomalies as defined by the user.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>observed</code></td>
<td><code></code></td>
<td>
<p>string that names the column in the data frame containing observed values.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>anomalies</code></td>
<td><code></code></td>
<td>
<p>string that names the column in the data frame containing booleans corresponding to anomalies where True = anomalous.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>model_limit</code></td>
<td><code></code></td>
<td>
<p>int for number of days used to limit the amount of data from which to generate forecasts and backcasts</p>
</td>
<td><code>6</code></td>
</tr>
<tr>
<td><code>savecasts</code></td>
<td><code></code></td>
<td>
<p>boolean used for saving the forecast as backcast data which can be used for analysis or plotting.</p>
</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>suppress_warnings</code></td>
<td><code></code></td>
<td>
<p>indicates whether warnings associated with ARIMA model development and fitting should be suppressed.</p>
</td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>df with additional columns</code></td>
<td>
<p>'det_cor' - determined correction
    'corrected' - boolean indicating whether the data was corrected
    'forecasts' - forecasted values used in correction (only created if savecasts=True)
    'backcasts' - backcasted values used in correction (only created if savecasts=True)</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
          <summary>Source code in <code>PyHydroQC/ARIMA_correct.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">generate_corrections</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">observed</span><span class="p">,</span> <span class="n">anomalies</span><span class="p">,</span> <span class="n">model_limit</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">savecasts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    generate_corrections passes through data with identified anomalies and determines corrections using ARIMA models.</span>
<span class="sd">    Corrections are determined by combining both a forecast and a backcast in a weighted average that is informed by</span>
<span class="sd">    non-anamolous data before and after anomalies. Corrections are generated for anomalies by order of the shortest to</span>
<span class="sd">    longest and those corrected values from the shorter anomalies are used with non-anomalous values to generate</span>
<span class="sd">    corrections for longer anomalies.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        df: data frame with columns for observations and anomalies as defined by the user.</span>
<span class="sd">        observed: string that names the column in the data frame containing observed values.</span>
<span class="sd">        anomalies: string that names the column in the data frame containing booleans corresponding to anomalies where True = anomalous.</span>
<span class="sd">        model_limit: int for number of days used to limit the amount of data from which to generate forecasts and backcasts</span>
<span class="sd">        savecasts: boolean used for saving the forecast as backcast data which can be used for analysis or plotting.</span>
<span class="sd">        suppress_warnings: indicates whether warnings associated with ARIMA model development and fitting should be suppressed.</span>
<span class="sd">    Returns:</span>
<span class="sd">        df with additional columns:</span>
<span class="sd">            'det_cor' - determined correction</span>
<span class="sd">            'corrected' - boolean indicating whether the data was corrected</span>
<span class="sd">            'forecasts' - forecasted values used in correction (only created if savecasts=True)</span>
<span class="sd">            'backcasts' - backcasted values used in correction (only created if savecasts=True)</span>
<span class="sd">    """</span>

    <span class="c1"># assign group index numbers to each set of consecutiveTrue/False data points</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">group_bools</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_in</span><span class="o">=</span><span class="n">anomalies</span><span class="p">,</span> <span class="n">column_out</span><span class="o">=</span><span class="s1">'group'</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">ARIMA_group</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">anomalies</span><span class="p">,</span> <span class="s1">'group'</span><span class="p">)</span>

    <span class="c1"># create new output columns</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'det_cor'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">observed</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">'corrected'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_event'</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">savecasts</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">'forecasts'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">'backcasts'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># while there are anomalous groups of points left to correct</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_event'</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># find an index for an anomalous ARIMA_group having the smallest number of points</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_event'</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">][</span><span class="s1">'ARIMA_group'</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># reset the conditionals</span>
        <span class="n">forecasted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">backcasted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># perform forecasting to generate corrected data points</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># if not at the beginning</span>
            <span class="c1"># forecast in forward direction</span>
            <span class="c1"># create an array of corrected data for current anomalous group</span>
            <span class="c1"># i-1 is the index of the previous group being used to forecast</span>
            <span class="n">pre_data</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)][</span><span class="n">observed</span><span class="p">]</span>  <span class="c1"># save off data for modeling</span>
            <span class="n">pre_data</span> <span class="o">=</span> <span class="n">pre_data</span><span class="p">[</span><span class="n">pre_data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">model_limit</span><span class="p">):</span><span class="n">pre_data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># limit data</span>
            <span class="c1"># generate the forecast data</span>
            <span class="n">yfor</span> <span class="o">=</span> <span class="n">ARIMA_forecast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pre_data</span><span class="p">),</span>
                                  <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]),</span>
                                  <span class="n">suppress_warnings</span><span class="p">)</span>

            <span class="n">forecasted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">savecasts</span><span class="p">):</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'forecasts'</span><span class="p">]</span> <span class="o">=</span> <span class="n">yfor</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">'forecasts'</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">'observed'</span><span class="p">]</span>

        <span class="c1"># perform backcasting to generate corrected data points</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">])):</span> <span class="c1"># if not at the end</span>
            <span class="c1"># forecast in reverse direction</span>
            <span class="c1"># data associated with group i+1 gets flipped for making a forecast</span>
            <span class="n">post_data</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)][</span><span class="n">observed</span><span class="p">]</span>  <span class="c1"># save off data for modeling</span>
            <span class="n">post_data</span> <span class="o">=</span> <span class="n">post_data</span><span class="p">[</span><span class="n">post_data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">post_data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">model_limit</span><span class="p">)]</span>  <span class="c1"># limit data</span>
            <span class="c1"># create backcast</span>
            <span class="n">yrev</span> <span class="o">=</span> <span class="n">ARIMA_forecast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">post_data</span><span class="p">)),</span>
                                  <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]),</span>
                                  <span class="n">suppress_warnings</span><span class="p">)</span>
            <span class="c1"># output is reversed, making what was forecast into a backcast</span>
            <span class="n">ybac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">yrev</span><span class="p">)</span>
            <span class="n">backcasted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">savecasts</span><span class="p">):</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'backcasts'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ybac</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">'backcasts'</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">'observed'</span><span class="p">]</span>

        <span class="c1"># fill the det_cor column using forecasted and backcasted conditionals</span>
        <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">forecasted</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">backcasted</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"ERROR: all data points are anomalous!"</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">forecasted</span><span class="p">):</span>  <span class="c1"># if there is no forecast</span>
            <span class="c1"># add the correction to the detected event</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'det_cor'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ybac</span>

            <span class="c1"># remove the ARIMA_event</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'ARIMA_event'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># decrement the following ARIMA_groups (to merge 0 and 1)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">backcasted</span><span class="p">):</span>  <span class="c1"># if there is no backcast</span>
            <span class="c1"># add the correction to the detected event</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'det_cor'</span><span class="p">]</span> <span class="o">=</span> <span class="n">yfor</span>

            <span class="c1"># remove the ARIMA_event</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'ARIMA_event'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># merge the last ARIMA_group after correction</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># both a forecast and a backcast exist</span>
            <span class="c1"># add the correction to the detected event</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'det_cor'</span><span class="p">]</span> <span class="o">=</span> <span class="n">anomaly_utilities</span><span class="o">.</span><span class="n">xfade</span><span class="p">(</span><span class="n">yfor</span><span class="p">,</span> <span class="n">ybac</span><span class="p">)</span>

            <span class="c1"># remove the ARIMA_event</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'ARIMA_event'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># merge the ARIMA_groups after correction</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># decrement the following ARIMA_groups</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">,</span> <span class="s1">'ARIMA_group'</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span>

    <span class="c1"># delete unused columns</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">'group'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">'ARIMA_event'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">'ARIMA_group'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
      
        <a href="about/" class="md-footer__link md-footer__link--next" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              About
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": ".", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "assets/javascripts/workers/search.217ffd95.min.js", "version": null}</script>
    
    
      <script src="assets/javascripts/bundle.926459b3.min.js"></script>
      
    
  </body>
</html>